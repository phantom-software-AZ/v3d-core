(()=>{"use strict";var e={677:e=>{e.exports="// replace vBumpUV with mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        vec2 TBNUV=gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n"},477:e=>{e.exports="uniform vec4 vEyePosition;\nuniform mat4 viewProjection;\nuniform mat4 view;\n\n// Colors\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n"},649:e=>{e.exports="#ifdef LIGHT{X}\n/**\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n    #else\n        #ifdef PBR\n\n            #ifdef SPOTLIGHT{X}\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #endif\n            preInfo.NdotV=NdotV;\n\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation=1.0;\n            #endif\n\n\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness=roughness;\n            #else\n                preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n            #endif\n\n            #ifdef HEMILIGHT{X}\n                info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n            #else\n               info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                   info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #else\n                   info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n\n                   preInfo.roughness=sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                      preInfo.roughness=sheenOut.sheenRoughness;\n                    #else\n                      preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef CLEARCOAT\n\n                #ifdef HEMILIGHT{X}\n                  preInfo.roughness=clearcoatOut.clearCoatRoughness;\n                #else\n                  preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                #endif\n                info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n                #ifdef CLEARCOAT_TINT\n\n                    absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\n                    info.diffuse*=absorption;\n                    #ifdef SPECULARTERM\n                        info.specular*=absorption;\n                    #endif\n                #endif\n\n                info.diffuse*=info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular*=info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen*=info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #elif defined(HEMILIGHT{X})\n                info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #endif\n        #endif\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n        #endif\n    #endif\n*/\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n                #else\n                    diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X}>=0.) {\n                    index{X}=i;\n                    break;\n                }\n            }\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X}>=0)\n            #endif\n            {\n            #if defined(SHADOWPCF{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #else\n                    shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #endif\n            #elif defined(SHADOWPCSS{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #else\n                    shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #endif\n            #else\n                shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n            #endif\n            #ifdef SHADOWCSMDEBUG{X}\n                shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n            #endif\n            #ifndef SHADOWCSMNOBLEND{X}\n                float frustumLength=frustumLengths{X}[index{X}];\n                float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\n                if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n                {\n                    index{X}+=1;\n                    float nextShadow=0.;\n                    #if defined(SHADOWPCF{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #else\n                            nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #endif\n                    #elif defined(SHADOWPCSS{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #else\n                            nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #endif\n                    #else\n                        nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                    #endif\n                    shadow=mix(nextShadow,shadow,diffRatio);\n                    #ifdef SHADOWCSMDEBUG{X}\n                        shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n                    #endif\n                }\n            #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow+=shadow;\n            shadowLightCount+=1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n/**\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n            #ifdef SPECULARTERM\n                specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase+=lightmapColor.rgb*shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase+=info.specular*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase+=info.sheen.rgb*shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase+=info.diffuse*shadowDebug{X};\n            #else\n                diffuseBase+=info.diffuse*shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase+=info.specular*shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase+=info.clearCoat.rgb*shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase+=info.sheen.rgb*shadow;\n            #endif\n        #endif\n    #endif\n*/\n\n    // ここで MToon のライティングを適用\n    #ifdef SPOTLIGHT{X}\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\n    #elif defined(HEMILIGHT{X})\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n        lightDirection = computeLightDirection(light{X}.vLightData);\n    #endif\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n    diffuseBase += mtoonDiffuse.rgb;\n    alpha = min(alpha, mtoonDiffuse.a);\n    #if defined(ALPHATEST) && ALPHATEST\n        alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n        if (alpha < alphaCutOff) {\n            discard;\n        }\n        alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n    #else\n        if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n            discard;\n        }\n    #endif\n#endif\n"},483:e=>{e.exports="#include<__decl__mtoonFragment>\n\n#if defined(BUMP) || !defined(NORMAL) || (defined(ALPHATEST) && ALPHATEST)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n//uniform vec3 vEyePosition;\n//uniform vec3 vAmbientColor;\n//#ifdef ALPHATEST\n//uniform float alphaCutOff;\n//#endif\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float isOutline;\nuniform vec4 time;\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n/**\n* DirectionalLight, PointLight の角度を計算\n*/\nvec3 computeLightDirection(vec4 lightData) {\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* SpotLight の角度を計算\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n     return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* HemisphericLight の角度を計算\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n     return normalize(lightData.xyz);\n}\n\n/**\n* MToon シェーダーの陰実装\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n     _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n     _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n// debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n    #define CUSTOM_FRAGMENT_MAIN_BEGIN\n    #ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n        #ifdef MTOON_OUTLINE_WIDTH_WORLD\n        #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n        #else\n            discard;\n        #endif\n    #endif\n\n    #include<clipPlaneFragment>\n    vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n\n    // Base color\n    // Strangely MToon decided to use base diffuse color as light color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n//    vec3 diffuseColor=vDiffuseColor.rgb;\n\n    // Alpha\n    float alpha = 1.0;\n//    float alpha = vDiffuseColor.a;\n\n// Bump\n#ifdef NORMAL\n     vec3 normalW = normalize(vNormalW);\n#else\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n\n// MToon UV\n// 全てのテクスチャは diffuse(_MainTex) の UV 情報を利用する\nvec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#elif defined(MAINUV3)\n    mainUv += vMainUV3;\n#elif defined(MAINUV4)\n    mainUv += vMainUV4;\n#elif defined(MAINUV5)\n    mainUv += vMainUV5;\n#elif defined(MAINUV6)\n    mainUv += vMainUV6;\n#endif\n\n// UV animation\nfloat uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\nuvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n// Translate UV in bottom-left origin coordinates.\n// UV is reversed\nmainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n\n// Rotate UV counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\nfloat rotateRad = uvAnimationRotation * PI_2 * uvAnim;\nvec2 rotatePivot = vec2(0.5, 0.5);\nmainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#include<mtoonBumpFragment>\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n#ifdef DIFFUSE\n//    baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n    #if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\n        if (baseColor.a<alphaCutOff)\n            discard;\n    #endif\n    #ifdef ALPHAFROMDIFFUSE\n        alpha*=baseColor.a;\n    #endif\n    #define CUSTOM_FRAGMENT_UPDATE_ALPHA\n    baseColor.rgb*=vDiffuseInfos.y;\n#endif\n\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\n// Ambient color\nvec3 baseAmbientColor = vec3(1., 1., 1.);\n#ifdef AMBIENT\n    baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\n    float glossiness=vSpecularColor.a;\n    vec3 specularColor=vSpecularColor.rgb;\n    #ifdef SPECULAR\n        vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\n        specularColor=specularMapColor.rgb;\n        #ifdef GLOSSINESS\n            glossiness=glossiness*specularMapColor.a;\n        #endif\n    #endif\n#else\n    float glossiness=0.;\n#endif\n\n// Lighting\nvec3 diffuseBase = vec3(0., 0., 0.);\nlightingInfo info;\n#ifdef SPECULARTERM\n    vec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow = 1.;\nvec3 lightDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n// 通常の lightFragment ではなく、自前実装の mtoonLightFragment を読み込む\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n#ifdef VERTEXALPHA\n    alpha*=vColor.a;\n#endif\n\n#ifdef ALPHATEST\n    #ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\n        if (alpha<alphaCutOff)\n            discard;\n    #endif\n    #ifndef ALPHABLEND\n        alpha=1.0;\n    #endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor.rgb;\n// MToon use emissive texture in a non-standard way\n//#ifdef EMISSIVE\n//    emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n//#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n    #ifdef LINKEMISSIVEWITHDIFFUSE\n        vec3 finalDiffuse=clamp((diffuseBase)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #else\n        vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #endif\n#endif\n#ifdef SPECULARTERM\n    vec3 finalSpecular=specularBase*specularColor;\n    #ifdef SPECULAROVERALPHA\n        alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n    #endif\n#else\n    vec3 finalSpecular=vec3(0.0);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular,0.0,1.0),alpha);\n#else\n    vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular,alpha);\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor=color;\n#endif\n}\n"},854:e=>{e.exports="// この include は特別で、 UboDeclaration または VertexDeclaration のどちらかに置換される\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// 基本的に default.vertex.fx を踏襲している\n\n// Attributes\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n\n// Additional Uniforms\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\nuniform float aspect;\nuniform float isOutline;\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n\n// Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n\nfloat outlineTex = 1.0;\nif (isOutline == 1.0) {\n#include<samplerVertexImplementation>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_MATRIXNAME_,outlineWidth,_INFONAME_,OutlineWidthInfos.x)\n#ifdef OUTLINE_WIDTH\n    #if defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #elif defined(MAINUV3)\n        vec2 vOutlineWidthUV = vMainUV3;\n    #elif defined(MAINUV4)\n        vec2 vOutlineWidthUV = vMainUV4;\n    #elif defined(MAINUV5)\n        vec2 vOutlineWidthUV = vMainUV5;\n    #elif defined(MAINUV6)\n        vec2 vOutlineWidthUV = vMainUV6;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n    outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n    // ワールド座標の normal 分だけ移動する\n    vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\n    positionUpdated.xyz += outlineOffset;\n#endif\n} // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\n        vNormalW=normalize(normalWorld*vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n    vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n    if (isOutline == 1.0) {\n        vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\n        projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n        projectedNormal.x *= aspect;\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy * clamp(\n            1.0 - abs(normalize(view * vec4(normalUpdated, 1.0)).z), 0.0, 1.0); // ignore offset when normal toward camera\n    }\n#endif\n\n    if (isOutline == 1.0) {\n        gl_Position.z += 1E-2 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,UvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n"},463:e=>{e.exports="// include<__decl__mtoonVertex> または include<__decl__mtoonFragment> と書いた時に WebGL2 の場合展開される\n// @see effect.ts\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vSpecularColor;\n    vec2 vSpecularInfos;\n    mat4 specularMatrix;\n    vec3 vAmbientColor;\n    vec2 vAmbientInfos;\n    mat4 ambientMatrix;\n    vec3 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n    float alphaCutOff;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n};\n\n// babylon specific\nuniform Scene {\n    mat4 viewProjection;\n#ifdef MULTIVIEW\n    mat4 viewProjectionR;\n#endif\n    mat4 view;\n    mat4 projection;\n    vec4 vEyePosition;\n};\n"},486:e=>{e.exports="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n"}},t={};function i(n){var o=t[n];if(void 0!==o)return o.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{i.r(n),i.d(n,{V3DCore:()=>X,default:()=>V});const e=BABYLON,t=LOADERS;class o extends t.GLTFFileLoader{constructor(){super(...arguments),this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}},this.vrmManager=null}createPlugin(){return new o}loadAsync(e,t,i,n,o){return this.uri=i,o&&(this.uri+=o),super.loadAsync(e,t,i,n,o)}}class r{constructor(e,t){this.offset=e,this.radius=t}}class a{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){this.colliders.push(new r(e,t))}}class s{constructor(e,t){this.position=e,this.radius=t}}class l{static multiplyByFloat(t,i){return new e.Vector3(t.x*i,t.y*i,t.z*i)}}class d{static multiplyWithVector3(t,i){const n=2*t.x,o=2*t.y,r=2*t.z,a=t.x*n,s=t.y*o,l=t.z*r,d=t.x*o,h=t.x*r,f=t.y*r,u=t.w*n,p=t.w*o,m=t.w*r,c=new e.Vector3;return c.x=(1-(s+l))*i.x+(d-m)*i.y+(h+p)*i.z,c.y=(d+m)*i.x+(1-(a+l))*i.y+(f-u)*i.z,c.z=(h-p)*i.x+(f+u)*i.y+(1-(a+s))*i.z,c}static fromToRotation(t,i){const n=e.Vector3.Cross(t,i).normalize(),o=e.Vector3.Dot(t,i),r=t.length()*i.length(),a=Math.acos(Math.max(0,Math.min(1,o/r))),s=Math.sin(a/2);return new e.Quaternion(s*n.x,s*n.y,s*n.z,Math.cos(a/2))}}class h{constructor(t,i,n,o){this.radius=i,this.transform=n,n.rotationQuaternion||(n.rotationQuaternion=n.rotation.toQuaternion());const r=n.parent;null!==r&&null===r.rotationQuaternion&&(r.rotationQuaternion=r.rotation.toQuaternion());const a=n.getAbsolutePosition().add(o);this.currentTail=this.getCenterTranslatedPos(t,a),this.prevTail=this.currentTail,this.localRotation=n.rotationQuaternion.clone(),this.boneAxis=e.Vector3.Normalize(o),this.boneLength=o.length()}update(e,t,i,n,o){const r=this.transform.getAbsolutePosition();if(Number.isNaN(r.x))return;const a=this.getCenterTranslatedWorldPos(e,this.currentTail),s=this.getCenterTranslatedWorldPos(e,this.prevTail);let h=a;{const e=1-i,t=l.multiplyByFloat(a.subtract(s),e);h.addInPlace(t)}{const e=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=d.multiplyWithVector3(e,this.boneAxis),n=l.multiplyByFloat(i,t);h.addInPlace(n)}h.addInPlace(n);{const e=h.subtract(r).normalize();h=r.add(l.multiplyByFloat(e,this.boneLength))}h=this.collide(o,h),this.prevTail=this.getCenterTranslatedPos(e,a),this.currentTail=this.getCenterTranslatedPos(e,h),this.setAbsoluteRotationQuaternion(this.transform,this.transformToRotation(h))}setAbsoluteRotationQuaternion(t,i){if(t.parent){const n=new e.Vector3(0,0,0),o=new e.Vector3(0,0,0),r=e.Quaternion.Identity(),a=e.Matrix.Identity();t.computeWorldMatrix(!0),t.getWorldMatrix().decompose(o,e.Quaternion.Identity(),n),e.Matrix.ComposeToRef(o,i,n,a);const s=e.Matrix.Identity(),l=e.Matrix.Identity();t.parent.computeWorldMatrix(!1),t.parent.getWorldMatrix().invertToRef(l),a.multiplyToRef(l,s),s.decompose(new e.Vector3(0,0,0),r,new e.Vector3(0,0,0)),t.rotationQuaternion?t.rotationQuaternion.copyFrom(r):r.toEulerAnglesToRef(t.rotation)}else t.rotationQuaternion=i}getAbsoluteRotationQuaternion(t){const i=e.Quaternion.Identity();return t?.computeWorldMatrix(!0),t?.getWorldMatrix().decompose(new e.Vector3(0,0,0),i,new e.Vector3(0,0,0)),i}getCenterTranslatedWorldPos(e,t){return null!==e?e.getAbsolutePosition().add(t):t}getCenterTranslatedPos(e,t){return null!==e?t.subtract(e.getAbsolutePosition()):t}transformToRotation(e){const t=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=d.multiplyWithVector3(t,this.boneAxis),n=e.subtract(this.transform.absolutePosition).normalize();return d.fromToRotation(i,n).multiplyInPlace(t)}collide(e,t){return e.forEach((e=>{const i=this.radius+e.radius,n=t.subtract(e.position);if(n.lengthSquared()<=i*i-.02){const o=e.position.add(l.multiplyByFloat(n.normalize(),i)),r=this.transform.absolutePosition;t=r.add(l.multiplyByFloat(o.subtractInPlace(r).normalize(),this.boneLength))}})),t}}class f{constructor(e,t,i,n,o,r,a,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=o,this.center=r,this.hitRadius=a,this.bones=s,this.colliderGroups=l,this.verlets=[],this.initialLocalRotations=[],this.activeBones=[],this.drawGizmo=!1,this.boneGizmoList=[],this.colliderGizmoList=[],this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{e.rotationQuaternion=e.rotationQuaternion||e.rotation.toQuaternion(),this.initialLocalRotations.push(e.rotationQuaternion.clone())}))}setup(e=!1){e||this.activeBones.forEach(((e,t)=>{e.rotationQuaternion=this.initialLocalRotations[t].clone()})),this.verlets=[],this.activeBones.forEach(((e,t)=>{this.initialLocalRotations[t]=e.rotationQuaternion,this.setupRecursive(this.center,e)}))}async update(t){if(0===this.verlets.length){if(0===this.activeBones.length)return;this.setup()}const i=[];this.colliderGroups.forEach((t=>{if(!t)return;const n=t.transform.getAbsolutePosition();Number.isNaN(n.x)||t.colliders.forEach((o=>{const r=n.add(o.offset);if(i.push(new s(r,o.radius)),this.drawGizmo){if(this.colliderGizmoList.length<i.length){const i=e.MeshBuilder.CreateSphere(`${t.transform.name}_colliderGizmo`,{segments:8,diameter:1,updatable:!0},t.transform.getScene()),n=new e.StandardMaterial(t.transform.name+"_colliderGizmomat",t.transform.getScene());n.emissiveColor=e.Color3.Yellow(),n.wireframe=!0,i.material=n,this.colliderGizmoList.push(i)}this.colliderGizmoList[i.length-1].position=r,this.colliderGizmoList[i.length-1].scaling=new e.Vector3(2*o.radius,2*o.radius,2*o.radius)}}))}));const n=this.stiffness*t,o=l.multiplyByFloat(this.gravityDir,this.gravityPower*t),r=this.verlets.map(((e,t)=>new Promise((r=>{e.update(this.center,n,this.dragForce,o,i),this.drawGizmo&&this.boneGizmoList[t]&&(this.boneGizmoList[t].position=e.transform.absolutePosition,this.boneGizmoList[t].rotationQuaternion=e.transform.rotationQuaternion),r()}))));return Promise.all(r).then((()=>{}))}setupRecursive(t,i){if(0===i.getChildTransformNodes().length){const e=i.parent,n=i.getAbsolutePosition().subtract(e.getAbsolutePosition()).normalize(),o=i.position.add(l.multiplyByFloat(n,.07));this.verlets.push(new h(t,this.hitRadius,i,o))}else{const e=i.getChildTransformNodes().shift(),n=e.position,o=e.scaling;this.verlets.push(new h(t,this.hitRadius,i,n.multiply(o)))}if(this.drawGizmo){const t=e.MeshBuilder.CreateSphere(i.name+"_boneGizmo",{segments:8,diameter:2*this.hitRadius,updatable:!0},i.getScene()),n=new e.StandardMaterial(i.name+"_boneGizmomat",i.getScene());n.emissiveColor=e.Color3.Red(),n.wireframe=!0,t.material=n,this.boneGizmoList.push(t)}i.getChildTransformNodes().forEach((e=>{this.setupRecursive(t,e)}))}}class u{constructor(e,t,i){this.ext=e;const n=this.constructColliderGroups(t);this.springs=this.constructSprings(t,n,i)}dispose(){this.springs=[]}setup(e=!1){this.springs.forEach((t=>{t.setup(e)}))}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(t){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const i=[];return this.ext.colliderGroups.forEach((n=>{const o=t(n.node),r=new a(o);n.colliders.forEach((t=>{r.addCollider(new e.Vector3(-t.offset.x,t.offset.y,-t.offset.z),t.radius)})),i.push(r)})),i}constructSprings(t,i,n){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const o=[];return this.ext.boneGroups.forEach((r=>{const a=(r.bones||[]).map((e=>t(e))),s=(r.colliderGroups||[]).map((e=>i[e]));o.push(new f(r.comment,n?.stiffness?n.stiffness:r.stiffiness,n?.gravityPower?n.gravityPower:r.gravityPower,n?.gravityDir?n.gravityDir:new e.Vector3(-r.gravityDir.x,-r.gravityDir.y,-r.gravityDir.z).normalize(),n?.dragForce?n.dragForce:r.dragForce,t(r.center),n?.hitRadius?n.hitRadius:r.hitRadius,a,s))})),o}}class p extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class m{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(e){const t=this.nodeMap[e];if(!t)throw new p(e);return t}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}class c{constructor(e,t,i,n,o){this.ext=e,this.scene=t,this.meshesFrom=i,this.transformNodesFrom=n,this.uri=o,this.morphTargetMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this._cameras=[],this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new u(this.ext.secondaryAnimation,this.findTransformNode.bind(this),{}),this.springBoneController.setup(),this.constructMorphTargetMap(),this.constructTransformNodeMap(),this._humanoidBone=new m(this.transformNodeMap),this.removeDuplicateSkeletons(),this._rootSkeleton=this.getRootSkeletonNode()}get cameras(){return this._cameras}appendCamera(e){this._cameras.push(e)}resetCameras(){this._cameras=[]}removeDuplicateSkeletons(){let e=null;for(const t of Object.keys(this.meshCache).map(Number)){const i=this.meshCache[t];if(i.length&&i[0].skeleton)if(e){e.bones.length!=i[0].skeleton.bones.length&&console.warn("Skeletons have different numbers of bones!"),i[0].skeleton.dispose();for(const t of i)t.skeleton=e}else if(e=i[0].skeleton,this._rootMesh){"Root"!==e.bones[0].name&&console.warn('The first bone has a different name than "Root"')}}}getRootSkeletonNode(){const e=this._rootMesh.getChildren((e=>"Root"===e.name||"Armature"===e.name));if(e.length>0)return e[0];{const e=this.scene.getNodeByName("Root")?this.scene.getNodeByName("Root"):this.scene.getNodeByName("Armature");if(e&&!e.parent)return e;throw Error("Cannot find root skeleton node!")}}async update(e){await this.springBoneController.update(e)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}morphingPreset(e,t){this.presetMorphTargetMap[e]&&this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const t=this.getFirstPersonBone();if(!t)return null;let i=t.getAbsolutePosition();const n=this.ext.firstPerson.firstPersonBoneOffset;return new e.Vector3(i.x+n.x,i.y+n.y,i.z+n.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}get rootSkeletonNode(){return this._rootSkeleton}findTransformNode(e){return this.transformNodeCache[e]||null}findMeshes(e){return this.meshCache[e]||null}constructMorphTargetMap(){this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const o=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:o,weight:t.weight}),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:o,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}}function g(e,t,i,n){var o,r=arguments.length,a=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(o=e[s])&&(a=(r<3?o(a):r>3?o(t,i,a):o(t,i))||a);return r>3&&a&&Object.defineProperty(t,i,a),a}Object.create;Object.create;function M(){return[{label:"DiffuseColor",propertyName:"diffuseColor",type:e.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:e.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:e.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:e.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:e.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:e.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:e.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:e.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:e.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:e.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:e.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:e.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:e.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:e.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:e.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:e.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:e.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:e.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:e.InspectableType.Slider,min:-.5,max:.5,step:.01}]}class _ extends e.MaterialDefines{constructor(){super(),this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.SPECULAR=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.SPECULARTERM=!1,this.NORMAL=!1,this.TANGENT=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.MULTIVIEW=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}class A{constructor(e,t){this.scene=e,this.material=t,this._savedDepthWrite=!1,this.name=`MToonOutline_${t.name}_${A.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine()}register(){this.scene._beforeRenderingMeshStage.registerStep(e.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(e.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){}render(t,i,n,o=!1){const r=i.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const a=i.getMesh(),s=a._internalAbstractMeshDataInfo._actAsRegularMesh?a:null,l=i.getRenderingMesh(),d=s||l,h=this.material.cullMode;this.material.cullMode=this.material.outlineCullMode,this._engine.enableEffect(r),l._bind(i,r,this.material.fillMode),this._engine.setZOffset(-1),e.Engine.Version.startsWith("4.0")||e.Engine.Version.startsWith("4.1")?l._processRendering(i,r,this.material.fillMode,n,this.isHardwareInstancedRendering(i,n),((e,n,o)=>{o.bindForSubMesh(n,t,i),r.setMatrix("world",n),r.setFloat("isOutline",1)}),this.material):l._processRendering(d,i,r,this.material.fillMode,n,this.isHardwareInstancedRendering(i,n),((e,n,o)=>{o.bindForSubMesh(n,t,i),r.setMatrix("world",n),r.setFloat("isOutline",1)}),this.material),this._engine.setZOffset(0),this.material.cullMode=h}_beforeRenderingMesh(t,i,n){if(this._savedDepthWrite=this._engine.getDepthWrite(),!this.willRender(i))return;const o=i.getMaterial();o.needAlphaBlendingForMesh(t)&&(this._engine.cacheStencilState(),this._engine.setDepthWrite(!1),this._engine.setColorWrite(!1),this._engine.setStencilBuffer(!0),this._engine.setStencilOperationPass(e.Constants.REPLACE),this._engine.setStencilFunction(e.Constants.ALWAYS),this._engine.setStencilMask(A._StencilReference),this._engine.setStencilFunctionReference(A._StencilReference),this.render(i.getRenderingMesh(),i,n,!0),this._engine.setColorWrite(!0),this._engine.setStencilFunction(e.Constants.NOTEQUAL)),this._engine.setDepthWrite(!1),this.render(i.getRenderingMesh(),i,n),this._engine.setDepthWrite(this._savedDepthWrite),o.needAlphaBlendingForMesh(t)&&this._engine.restoreStencilState()}_afterRenderingMesh(e,t,i){this.willRender(t)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(t.getRenderingMesh(),t,i),this._engine.setColorWrite(!0))}isHardwareInstancedRendering(e,t){if(!this._engine.getCaps().instancedArrays)return!1;let i=!1;return i=e.getRenderingMesh().hasThinInstances,null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]||i}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}A._StencilReference=4,A.rendererId=0;const v=i(463),T=i(486),S=i(477),I=i(677),x=i(649),E=i(854),L=i(483);var D,C,N,O;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(D||(D={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(C||(C={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(N||(N={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(O||(O={}));const R={effect:null,subMesh:null};class b extends e.PushMaterial{constructor(t,i){super(t,i),this._diffuseTexture=null,this._ambientTexture=null,this._emissiveTexture=null,this._specularTexture=null,this._bumpTexture=null,this._shadeTexture=null,this._receiveShadowTexture=null,this._shadingGradeTexture=null,this._rimTexture=null,this._matCapTexture=null,this._outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.ambientColor=new e.Color3(0,0,0),this.diffuseColor=new e.Color3(1,1,1),this.specularColor=new e.Color3(1,1,1),this.emissiveColor=new e.Color3(0,0,0),this.shadeColor=new e.Color3(.97,.81,.86),this.rimColor=new e.Color3(0,0,0),this.outlineColor=new e.Color3(0,0,0),this.specularPower=64,this._useAlphaFromDiffuseTexture=!0,this._useEmissiveAsIllumination=!1,this._linkEmissiveWithDiffuse=!1,this._useSpecularOverAlpha=!1,this._disableLighting=!1,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this.alphaCutOff=.4,this._useGlossinessFromSpecularMapAlpha=!1,this._maxSimultaneousLights=16,this._twoSidedLighting=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.detailMap=new e.DetailMapConfiguration(this._markAllSubMeshesAsTexturesDirty.bind(this)),this._worldViewProjectionMatrix=e.Matrix.Zero(),this._globalAmbientColor=new e.Color3(0,0,0),this._bumpScale=.1,this.parallaxScaleBias=this._bumpScale,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._debugMode=D.None,this.debugMode=D.None,this.outlineRenderer=new A(this.getScene(),this),this._outlineWidthMode=N.None,this.outlineWidthMode=N.None,this._outlineColorMode=C.MixedLighting,this.outlineColorMode=C.MixedLighting,this._cullMode=O.Back,this._outlineCullMode=O.Front,this.outlineCullMode=O.Front,this.storedCullMode=O.Back,this.prePassConfiguration=new e.PrePassConfiguration,e.Effect.ShadersStore.mtoonVertexShader&&e.Effect.ShadersStore.mtoonFragmentShader||(e.Effect.IncludesShadersStore.mtoonUboDeclaration=v,e.Effect.IncludesShadersStore.mtoonVertexDeclaration=T,e.Effect.IncludesShadersStore.mtoonFragmentDeclaration=S,e.Effect.IncludesShadersStore.mtoonLightFragment=x,e.Effect.IncludesShadersStore.mtoonBumpFragment=I,e.Effect.ShadersStore.mtoonVertexShader=E,e.Effect.ShadersStore.mtoonFragmentShader=L),this.inspectableCustomProperties=this.inspectableCustomProperties?this.inspectableCustomProperties.concat(M()):M()}appendedActiveTextures(){return[this._diffuseTexture,this._ambientTexture,this._emissiveTexture,this._specularTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture].filter((e=>null!==e))}get isPrePassCapable(){return!0}get canRenderToMRT(){return!1}get cullMode(){return this._cullMode}set cullMode(t){switch(this._cullMode=t,this._cullMode){case O.Off:this.backFaceCulling=!1,this.sideOrientation=e.Material.ClockWiseSideOrientation,this.twoSidedLighting=!0;break;case O.Front:this.backFaceCulling=!0,this.sideOrientation=e.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!1;break;case O.Back:this.backFaceCulling=!0,this.sideOrientation=e.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this.markAsDirty(e.Material.TextureDirtyFlag)}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported,this._markAllSubMeshesAsMiscDirty()}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===e.Material.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==e.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(t,i,n=!1){if(i.effect&&this.isFrozen&&i.effect._wasPreviouslyReady)return!0;i._materialDefines||(i.materialDefines=new _);const o=this.getScene(),r=i._materialDefines;if(this._isReadyForSubMesh(i))return!0;const a=o.getEngine();if(r._needNormals=e.MaterialHelper.PrepareDefinesForLights(o,t,r,!0,this._maxSimultaneousLights,this._disableLighting)||this.outlineWidthMode!==N.None,e.MaterialHelper.PrepareDefinesForMultiview(o,r),e.MaterialHelper.PrepareDefinesForPrePass(o,r,this.canRenderToMRT),r._areTexturesDirty){this.applyDefines(r),r._needUVs=!1;for(let t=1;t<=e.Constants.MAX_SUPPORTED_UV_SETS;++t)r["MAINUV"+t]=!1;if(o.texturesEnabled){if(this._diffuseTexture&&b.DiffuseTextureEnabled){if(!this._diffuseTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture,r,"DIFFUSE")}else r.DIFFUSE=!1;if(this._ambientTexture&&b.AmbientTextureEnabled){if(!this._ambientTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture,r,"AMBIENT")}else r.AMBIENT=!1;if(this._emissiveTexture&&b.EmissiveTextureEnabled){if(!this._emissiveTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture,r,"EMISSIVE")}else r.EMISSIVE=!1;if(this._specularTexture&&b.SpecularTextureEnabled){if(!this._specularTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture,r,"SPECULAR"),r.GLOSSINESS=this._useGlossinessFromSpecularMapAlpha}else r.SPECULAR=!1;if(o.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,r,"BUMP"),r.PARALLAX=this._useParallax,r.PARALLAXOCCLUSION=this._useParallaxOcclusion,r.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap}else r.BUMP=!1;if(this._shadeTexture){if(!this._shadeTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._shadeTexture,r,"SHADE")}else r.SHADE=!1;if(this._receiveShadowTexture){if(!this._receiveShadowTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._receiveShadowTexture,r,"RECEIVE_SHADOW")}else r.RECEIVE_SHADOW=!1;if(this._shadingGradeTexture){if(!this._shadingGradeTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._shadingGradeTexture,r,"SHADING_GRADE")}else r.SHADING_GRADE=!1;if(this._rimTexture){if(!this._rimTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._rimTexture,r,"RIM")}else r.RIM=!1;if(this._matCapTexture){if(!this._matCapTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._matCapTexture,r,"MATCAP")}else r.MATCAP=!1;if(this._outlineWidthTexture){if(!this._outlineWidthTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._outlineWidthTexture,r,"OUTLINE_WIDTH")}else r.OUTLINE_WIDTH=!1;if(this._uvAnimationMaskTexture){if(!this._uvAnimationMaskTexture.isReadyOrNotBlocking())return!1;e.MaterialHelper.PrepareDefinesForMergedUV(this._uvAnimationMaskTexture,r,"UV_ANIMATION_MASK")}else r.UV_ANIMATION_MASK=!1;r.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else r.DIFFUSE=!1,r.AMBIENT=!1,r.EMISSIVE=!1,r.BUMP=!1,r.SHADE=!1,r.RECEIVE_SHADOW=!1,r.SHADING_GRADE=!1,r.RIM=!1,r.MATCAP=!1,r.OUTLINE_WIDTH=!1,r.UV_ANIMATION_MASK=!1;r.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),r.EMISSIVEASILLUMINATION=this._useEmissiveAsIllumination,r.LINKEMISSIVEWITHDIFFUSE=this._linkEmissiveWithDiffuse,r.SPECULAROVERALPHA=this._useSpecularOverAlpha,r.PREMULTIPLYALPHA=this.alphaMode===e.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===e.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,r.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,r.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(t)}if(!this.detailMap.isReadyForSubMesh(r,o))return!1;if(e.MaterialHelper.PrepareDefinesForMisc(t,o,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(t)||this._forceAlphaTest,r),e.MaterialHelper.PrepareDefinesForAttributes(t,r,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),e.MaterialHelper.PrepareDefinesForFrameBoundValues(o,a,r,n,null,i.getRenderingMesh().hasThinInstances),this.detailMap.prepareDefines(r,o),r.isDirty){const n=r._areLightsDisposed;r.markAsProcessed();const s=new e.EffectFallbacks;r.SPECULAR&&s.addFallback(0,"SPECULAR"),r.BUMP&&s.addFallback(0,"BUMP"),r.PARALLAX&&s.addFallback(1,"PARALLAX"),r.PARALLAXOCCLUSION&&s.addFallback(0,"PARALLAXOCCLUSION"),r.SPECULAROVERALPHA&&s.addFallback(0,"SPECULAROVERALPHA"),r.FOG&&s.addFallback(1,"FOG"),r.POINTSIZE&&s.addFallback(0,"POINTSIZE"),r.LOGARITHMICDEPTH&&s.addFallback(0,"LOGARITHMICDEPTH"),e.MaterialHelper.HandleFallbacksForShadows(r,s,this._maxSimultaneousLights),r.SPECULARTERM&&s.addFallback(0,"SPECULARTERM"),r.MULTIVIEW&&s.addFallback(0,"MULTIVIEW");const l=[e.VertexBuffer.PositionKind];r.NORMAL&&l.push(e.VertexBuffer.NormalKind),r.TANGENT&&l.push(e.VertexBuffer.TangentKind);for(let t=1;t<=e.Constants.MAX_SUPPORTED_UV_SETS;++t)r["UV"+t]&&l.push(`uv${1===t?"":t}`);r.VERTEXCOLOR&&l.push(e.VertexBuffer.ColorKind),e.MaterialHelper.PrepareAttributesForBones(l,t,r,s),e.MaterialHelper.PrepareAttributesForInstances(l,r),e.MaterialHelper.PrepareAttributesForMorphTargets(l,t,r);let d="mtoon";const h=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","visibility","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","diffuseMatrix","ambientMatrix","emissiveMatrix","specularMatrix","bumpMatrix","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","morphTargetTextureInfo","morphTargetTextureIndices"],f=["diffuseSampler","ambientSampler","emissiveSampler","specularSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler","morphTargets"],u=["Material","Scene"];e.DetailMapConfiguration.AddUniforms(h),e.DetailMapConfiguration.AddSamplers(f),e.PrePassConfiguration.AddUniforms(h),e.PrePassConfiguration.AddSamplers(f),e.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:h,uniformBuffersNames:u,samplers:f,defines:r,maxSimultaneousLights:this._maxSimultaneousLights});const p={};this.customShaderNameResolve&&(d=this.customShaderNameResolve(d,h,u,f,r,l,p));const m=r.toString(),c=i.effect;let g=o.getEngine().createEffect(d,{attributes:l,uniformsNames:h,uniformBuffersNames:u,samplers:f,defines:m,fallbacks:s,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:r.NUM_MORPH_INFLUENCERS},processFinalCode:p.processFinalCode,multiTarget:r.PREPASS},a);if(g)if(this._onEffectCreatedObservable&&(R.effect=g,R.subMesh=i,this._onEffectCreatedObservable.notifyObservers(R)),this.allowShaderHotSwapping&&c&&!g.isReady()){if(g=c,r.markAsUnprocessed(),n)return r._areLightsDisposed=!0,!1}else o.resetCachedMaterial(),i.setEffect(g,r,this._materialContext),this.buildUniformLayout()}return!(!i.effect||!i.effect.isReady())&&(r._renderId=o.getRenderId(),i.effect._wasPreviouslyReady=!0,!0)}buildUniformLayout(){const t=this._uniformBuffer;t.addUniform("vDiffuseColor",4),t.addUniform("vDiffuseInfos",2),t.addUniform("diffuseMatrix",16),t.addUniform("vSpecularColor",4),t.addUniform("vSpecularInfos",2),t.addUniform("specularMatrix",16),t.addUniform("vAmbientColor",3),t.addUniform("vAmbientInfos",2),t.addUniform("ambientMatrix",16),t.addUniform("vEmissiveColor",3),t.addUniform("vEmissiveInfos",2),t.addUniform("emissiveMatrix",16),t.addUniform("vBumpInfos",3),t.addUniform("bumpMatrix",16),t.addUniform("vShadeColor",3),t.addUniform("vShadeInfos",2),t.addUniform("shadeMatrix",16),t.addUniform("vReceiveShadowInfos",2),t.addUniform("receiveShadowMatrix",16),t.addUniform("vShadingGradeInfos",2),t.addUniform("shadingGradeMatrix",16),t.addUniform("vRimColor",3),t.addUniform("vRimInfos",2),t.addUniform("rimMatrix",16),t.addUniform("vMatCapInfos",2),t.addUniform("matCapMatrix",16),t.addUniform("vOutlineColor",3),t.addUniform("vOutlineWidthInfos",2),t.addUniform("outlineWidthMatrix",16),t.addUniform("vUvAnimationMaskInfos",2),t.addUniform("uvAnimationMaskMatrix",16),t.addUniform("vTangentSpaceParams",2),t.addUniform("pointSize",1),t.addUniform("alphaCutOff",1),t.addUniform("shadingGradeRate",1),t.addUniform("receiveShadowRate",1),t.addUniform("shadeShift",1),t.addUniform("shadeToony",1),t.addUniform("lightColorAttenuation",1),t.addUniform("indirectLightIntensity",1),t.addUniform("rimLightingMix",1),t.addUniform("rimFresnelPower",1),t.addUniform("rimLift",1),t.addUniform("outlineWidth",1),t.addUniform("outlineScaledMaxDistance",1),t.addUniform("outlineLightingMix",1),t.addUniform("uvAnimationScrollX",1),t.addUniform("uvAnimationScrollY",1),t.addUniform("uvAnimationRotation",1),e.DetailMapConfiguration.PrepareUniformBuffer(t),t.create()}unbind(){super.unbind()}bindForSubMesh(t,i,n){const o=this.getScene(),r=n._materialDefines;if(!r)return;const a=n.effect;if(!a)return;this._activeEffect=a,i.getMeshUniformBuffer().bindToEffect(a,"Mesh"),i.transferToEffect(t),this.prePassConfiguration.bindForSubMesh(this._activeEffect,o,i,t,this.isFrozen),r.OBJECTSPACE_NORMALMAP&&(t.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const s=this._mustRebind(o,a,i.visibility);e.MaterialHelper.BindBonesParameters(i,a);const l=this._uniformBuffer;s&&(l.bindToEffect(a,"Material"),this.bindViewProjection(a),l.useUbo&&this.isFrozen&&l.isSync||o.texturesEnabled&&(this._diffuseTexture&&b.DiffuseTextureEnabled&&(l.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),e.MaterialHelper.BindTextureMatrix(this._diffuseTexture,l,"diffuse")),this._ambientTexture&&b.AmbientTextureEnabled&&(l.updateFloat2("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level),e.MaterialHelper.BindTextureMatrix(this._ambientTexture,l,"ambient")),this._hasAlphaChannel()&&l.updateFloat("alphaCutOff",this.alphaCutOff),this._emissiveTexture&&b.EmissiveTextureEnabled&&(l.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),e.MaterialHelper.BindTextureMatrix(this._emissiveTexture,l,"emissive")),this._specularTexture&&b.SpecularTextureEnabled&&(l.updateFloat2("vSpecularInfos",this._specularTexture.coordinatesIndex,this._specularTexture.level),e.MaterialHelper.BindTextureMatrix(this._specularTexture,l,"specular")),this._bumpTexture&&o.getEngine().getCaps().standardDerivatives&&b.BumpTextureEnabled&&(l.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this.parallaxScaleBias),e.MaterialHelper.BindTextureMatrix(this._bumpTexture,l,"bump"),o._mirroredCameraPosition?l.updateFloat2("vTangentSpaceParams",-1,-1):l.updateFloat2("vTangentSpaceParams",1,1)),this._shadeTexture&&(l.updateFloat2("vShadeInfos",this._shadeTexture.coordinatesIndex,this._shadeTexture.level),e.MaterialHelper.BindTextureMatrix(this._shadeTexture,l,"shade")),this._receiveShadowTexture&&(l.updateFloat2("vReceiveShadowInfos",this._receiveShadowTexture.coordinatesIndex,this._receiveShadowTexture.level),e.MaterialHelper.BindTextureMatrix(this._receiveShadowTexture,l,"receiveShadow")),this._shadingGradeTexture&&(l.updateFloat2("vShadingGradeInfos",this._shadingGradeTexture.coordinatesIndex,this._shadingGradeTexture.level),e.MaterialHelper.BindTextureMatrix(this._shadingGradeTexture,l,"shadingGrade")),this._rimTexture&&(l.updateFloat2("vRimInfos",this._rimTexture.coordinatesIndex,this._rimTexture.level),e.MaterialHelper.BindTextureMatrix(this._rimTexture,l,"rim")),this._matCapTexture&&(l.updateFloat2("vMatCapInfos",this._matCapTexture.coordinatesIndex,this._matCapTexture.level),e.MaterialHelper.BindTextureMatrix(this._matCapTexture,l,"matCap")),this._outlineWidthTexture&&(l.updateFloat2("vOutlineWidthInfos",this._outlineWidthTexture.coordinatesIndex,this._outlineWidthTexture.level),e.MaterialHelper.BindTextureMatrix(this._outlineWidthTexture,l,"outlineWidth")),this._uvAnimationMaskTexture&&(l.updateFloat2("vUvAnimationMaskInfos",this._uvAnimationMaskTexture.coordinatesIndex,this._uvAnimationMaskTexture.level),e.MaterialHelper.BindTextureMatrix(this._uvAnimationMaskTexture,l,"uvAnimationMask"))),this.pointsCloud&&l.updateFloat("pointSize",this.pointSize),r.SPECULARTERM&&l.updateColor4("vSpecularColor",this.specularColor,this.specularPower),l.updateColor3("vEmissiveColor",this.emissiveColor),l.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),o.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),l.updateColor3("vAmbientColor",this._globalAmbientColor),l.updateFloat("receiveShadowRate",this._receiveShadowRate),l.updateFloat("shadingGradeRate",this._shadingGradeRate),l.updateFloat("shadeShift",this._shadeShift),l.updateFloat("shadeToony",this._shadeToony),l.updateFloat("lightColorAttenuation",this._lightColorAttenuation),l.updateFloat("indirectLightIntensity",this._indirectLightIntensity),l.updateFloat("rimLightingMix",this._rimLightingMix),l.updateFloat("rimFresnelPower",this._rimFresnelPower),l.updateFloat("rimLift",this._rimLift),l.updateFloat("outlineWidth",this._outlineWidth),l.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),l.updateFloat("outlineLightingMix",this._outlineLightingMix),l.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),l.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),l.updateFloat("uvAnimationRotation",this._uvAnimationRotation),o.texturesEnabled&&(this._diffuseTexture&&b.DiffuseTextureEnabled&&a.setTexture("diffuseSampler",this._diffuseTexture),this._ambientTexture&&b.AmbientTextureEnabled&&a.setTexture("ambientSampler",this._ambientTexture),this._emissiveTexture&&b.EmissiveTextureEnabled&&a.setTexture("emissiveSampler",this._emissiveTexture),this._specularTexture&&b.SpecularTextureEnabled&&a.setTexture("specularSampler",this._specularTexture),this._bumpTexture&&o.getEngine().getCaps().standardDerivatives&&b.BumpTextureEnabled&&a.setTexture("bumpSampler",this._bumpTexture),this._shadeTexture&&a.setTexture("shadeSampler",this._shadeTexture),this._receiveShadowTexture&&a.setTexture("receiveShadowSampler",this._receiveShadowTexture),this._shadingGradeTexture&&a.setTexture("shadingGradeSampler",this._shadingGradeTexture),this._rimTexture&&a.setTexture("rimSampler",this._rimTexture),this._matCapTexture&&a.setTexture("matCapSampler",this._matCapTexture),this._outlineWidthTexture&&a.setTexture("outlineWidthSampler",this._outlineWidthTexture),this._uvAnimationMaskTexture&&a.setTexture("uvAnimationMaskSampler",this._uvAnimationMaskTexture)),this.detailMap.bindForSubMesh(l,o,this.isFrozen),e.MaterialHelper.BindClipPlane(a,o),this.bindEyePosition(a),a.setVector3("vEyeUp",o.activeCamera.upVector),l.updateColor3("vShadeColor",this.shadeColor),l.updateColor3("vRimColor",this.rimColor),l.updateColor4("vOutlineColor",this.outlineColor,1)),!s&&this.isFrozen||(o.lightsEnabled&&!this._disableLighting&&e.MaterialHelper.BindLights(o,i,a,r,this._maxSimultaneousLights),(o.fogEnabled&&i.applyFog&&o.fogMode!==e.Scene.FOGMODE_NONE||i.receiveShadows)&&this.bindView(a),e.MaterialHelper.BindFogParameters(o,i,a),r.NUM_MORPH_INFLUENCERS&&e.MaterialHelper.BindMorphTargetParameters(i,a),this.useLogarithmicDepth&&e.MaterialHelper.BindLogDepth(r,a,o)),a.setFloat("aspect",o.getEngine().getAspectRatio(o.activeCamera)),a.setFloat("isOutline",0);const d=window.performance.now()/1e3;a.setVector4("time",new e.Vector4(d/20,d,2*d,3*d)),this._afterBind(i,this._activeEffect),l.update()}getAnimatables(){const e=[];for(const t of this.appendedActiveTextures())t.animations&&t.animations.length>0&&e.push(t);return this.detailMap.getAnimatables(e),e}getActiveTextures(){const e=super.getActiveTextures().concat(this.appendedActiveTextures());return this.detailMap.getActiveTextures(e),e}hasTexture(e){if(super.hasTexture(e))return!0;const t=this.appendedActiveTextures();return t.length>0?t.some((t=>t===e)):this.detailMap.hasTexture(e)}dispose(e,t){t&&this.appendedActiveTextures().forEach((e=>e.dispose())),this.detailMap.dispose(t),super.dispose(e,t)}applyDefines(e){switch(this._debugMode){case D.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case D.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case D.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this._outlineWidthMode){case N.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case N.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case N.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this._outlineColorMode){case C.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case C.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}clone(t){const i=e.SerializationHelper.Clone((()=>new b(t,this.getScene())),this);return i.name=t,i.id=t,this.stencil.copyTo(i.stencil),i}serialize(){const t=e.SerializationHelper.Serialize(this);return t.stencil=this.stencil.serialize(),t}static Parse(t,i,n){const o=e.SerializationHelper.Parse((()=>new b(t.name,i)),t,i,n);return t.stencil&&o.stencil.parse(t.stencil,i,n),o}static get DiffuseTextureEnabled(){return e.MaterialFlags.DiffuseTextureEnabled}static set DiffuseTextureEnabled(t){e.MaterialFlags.DiffuseTextureEnabled=t}static get AmbientTextureEnabled(){return e.MaterialFlags.AmbientTextureEnabled}static set AmbientTextureEnabled(t){e.MaterialFlags.AmbientTextureEnabled=t}static get EmissiveTextureEnabled(){return e.MaterialFlags.EmissiveTextureEnabled}static set EmissiveTextureEnabled(t){e.MaterialFlags.EmissiveTextureEnabled=t}static get SpecularTextureEnabled(){return e.MaterialFlags.SpecularTextureEnabled}static set SpecularTextureEnabled(t){e.MaterialFlags.SpecularTextureEnabled=t}static get BumpTextureEnabled(){return e.MaterialFlags.BumpTextureEnabled}static set BumpTextureEnabled(t){e.MaterialFlags.BumpTextureEnabled=t}}var P;g([(0,e.serializeAsTexture)("diffuseTexture")],b.prototype,"_diffuseTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],b.prototype,"diffuseTexture",void 0),g([(0,e.serializeAsTexture)("ambientTexture")],b.prototype,"_ambientTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"ambientTexture",void 0),g([(0,e.serializeAsTexture)("emissiveTexture")],b.prototype,"_emissiveTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"emissiveTexture",void 0),g([(0,e.serializeAsTexture)("specularTexture")],b.prototype,"_specularTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"specularTexture",void 0),g([(0,e.serializeAsTexture)("bumpTexture")],b.prototype,"_bumpTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"bumpTexture",void 0),g([(0,e.serializeAsTexture)("shadeTexture")],b.prototype,"_shadeTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"shadeTexture",void 0),g([(0,e.serializeAsTexture)("receiveShadowTexture")],b.prototype,"_receiveShadowTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"receiveShadowTexture",void 0),g([(0,e.serializeAsTexture)("shadingGradeTexture")],b.prototype,"_shadingGradeTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"shadingGradeTexture",void 0),g([(0,e.serializeAsTexture)("rimTexture")],b.prototype,"_rimTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"rimTexture",void 0),g([(0,e.serializeAsTexture)("matCapTexture")],b.prototype,"_matCapTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"matCapTexture",void 0),g([(0,e.serializeAsTexture)("outlineWidthTexture")],b.prototype,"_outlineWidthTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"outlineWidthTexture",void 0),g([(0,e.serializeAsTexture)("uvAnimationMaskTexture")],b.prototype,"_uvAnimationMaskTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"uvAnimationMaskTexture",void 0),g([(0,e.serializeAsColor3)("ambient")],b.prototype,"ambientColor",void 0),g([(0,e.serializeAsColor3)("diffuse")],b.prototype,"diffuseColor",void 0),g([(0,e.serializeAsColor3)("specular")],b.prototype,"specularColor",void 0),g([(0,e.serializeAsColor3)("emissive")],b.prototype,"emissiveColor",void 0),g([(0,e.serializeAsColor3)("shade")],b.prototype,"shadeColor",void 0),g([(0,e.serializeAsColor3)("rim")],b.prototype,"rimColor",void 0),g([(0,e.serializeAsColor3)("outline")],b.prototype,"outlineColor",void 0),g([(0,e.serialize)()],b.prototype,"specularPower",void 0),g([(0,e.serialize)("useAlphaFromDiffuseTexture")],b.prototype,"_useAlphaFromDiffuseTexture",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],b.prototype,"useAlphaFromDiffuseTexture",void 0),g([(0,e.serialize)("useEmissiveAsIllumination")],b.prototype,"_useEmissiveAsIllumination",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useEmissiveAsIllumination",void 0),g([(0,e.serialize)("linkEmissiveWithDiffuse")],b.prototype,"_linkEmissiveWithDiffuse",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"linkEmissiveWithDiffuse",void 0),g([(0,e.serialize)("useSpecularOverAlpha")],b.prototype,"_useSpecularOverAlpha",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useSpecularOverAlpha",void 0),g([(0,e.serialize)("disableLighting")],b.prototype,"_disableLighting",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"disableLighting",void 0),g([(0,e.serialize)("useObjectSpaceNormalMap")],b.prototype,"_useObjectSpaceNormalMap",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useObjectSpaceNormalMap",void 0),g([(0,e.serialize)("useParallax")],b.prototype,"_useParallax",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useParallax",void 0),g([(0,e.serialize)("useParallaxOcclusion")],b.prototype,"_useParallaxOcclusion",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useParallaxOcclusion",void 0),g([(0,e.serialize)()],b.prototype,"alphaCutOff",void 0),g([(0,e.serialize)("useGlossinessFromSpecularMapAlpha")],b.prototype,"_useGlossinessFromSpecularMapAlpha",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"useGlossinessFromSpecularMapAlpha",void 0),g([(0,e.serialize)("maxSimultaneousLights")],b.prototype,"_maxSimultaneousLights",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"maxSimultaneousLights",void 0),g([(0,e.serialize)("twoSidedLighting")],b.prototype,"_twoSidedLighting",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],b.prototype,"twoSidedLighting",void 0),g([(0,e.serialize)("bumpScale")],b.prototype,"_bumpScale",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],b.prototype,"bumpScale",void 0),g([(0,e.serialize)()],b.prototype,"parallaxScaleBias",void 0),g([(0,e.serialize)("receiveShadowRate")],b.prototype,"_receiveShadowRate",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"receiveShadowRate",void 0),g([(0,e.serialize)("shadingGradeRate")],b.prototype,"_shadingGradeRate",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"shadingGradeRate",void 0),g([(0,e.serialize)("shadeShift")],b.prototype,"_shadeShift",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"shadeShift",void 0),g([(0,e.serialize)("shadeToony")],b.prototype,"_shadeToony",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"shadeToony",void 0),g([(0,e.serialize)("lightColorAttenuation")],b.prototype,"_lightColorAttenuation",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"lightColorAttenuation",void 0),g([(0,e.serialize)("indirectLightIntensity")],b.prototype,"_indirectLightIntensity",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"indirectLightIntensity",void 0),g([(0,e.serialize)("rimLightingMix")],b.prototype,"_rimLightingMix",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"rimLightingMix",void 0),g([(0,e.serialize)("rimFresnelPower")],b.prototype,"_rimFresnelPower",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"rimFresnelPower",void 0),g([(0,e.serialize)("rimLift")],b.prototype,"_rimLift",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsLightsDirty")],b.prototype,"rimLift",void 0),g([(0,e.serialize)("outlineWidth")],b.prototype,"_outlineWidth",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],b.prototype,"outlineWidth",void 0),g([(0,e.serialize)("outlineScaledMaxDistance")],b.prototype,"_outlineScaledMaxDistance",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],b.prototype,"outlineScaledMaxDistance",void 0),g([(0,e.serialize)("outlineLightingMix")],b.prototype,"_outlineLightingMix",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],b.prototype,"outlineLightingMix",void 0),g([(0,e.serialize)("uvAnimationScrollX")],b.prototype,"_uvAnimationScrollX",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"uvAnimationScrollX",void 0),g([(0,e.serialize)("uvAnimationScrollY")],b.prototype,"_uvAnimationScrollY",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"uvAnimationScrollY",void 0),g([(0,e.serialize)("uvAnimationRotation")],b.prototype,"_uvAnimationRotation",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"uvAnimationRotation",void 0),g([(0,e.serialize)("debugMode")],b.prototype,"_debugMode",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"debugMode",void 0),g([(0,e.serialize)("outlineWidthMode")],b.prototype,"_outlineWidthMode",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"outlineWidthMode",void 0),g([(0,e.serialize)("outlineColorMode")],b.prototype,"_outlineColorMode",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"outlineColorMode",void 0),g([(0,e.serialize)("cullMode")],b.prototype,"_cullMode",void 0),g([(0,e.serialize)("outlineCullMode")],b.prototype,"_outlineCullMode",void 0),g([(0,e.expandToProperty)("_markAllSubMeshesAsMiscDirty")],b.prototype,"outlineCullMode",void 0),g([(0,e.serialize)()],b.prototype,"useLogarithmicDepth",null),e._TypeStore.RegisteredTypes["BABYLON.MToonMaterial"]=b,function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(P||(P={}));class y{constructor(e){this.loader=e}generate(e,t,i,n,o){const r=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!r)return null;i.alphaIndex=r.renderQueue;const a=this.createMaterialByShader(e,t,n,r);return a?(o(a),a instanceof b?this.loadMToonTexturesAsync(e,a,r):Promise.resolve(a)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],o=i.vectorProperties._MainTex;if(!o)return Promise.resolve(t);const r=(t,i)=>{w(t,(r=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:r},(e=>{const t=e;t.uOffset=o[0],t.vOffset=o[1],t.uScale=o[2],t.vScale=o[3],i(e)})))}))};return r(i.textureProperties._MainTex,(e=>{t.diffuseTexture=e,t.transparencyMode&&(t.diffuseTexture.hasAlpha=!0)})),r(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),r(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),r(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),r(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),r(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),r(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),r(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),r(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),r(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===P.VRMMToon){const e=new b(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===P.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(t,i){w(i.floatProperties._Cutoff,(e=>t.alphaCutOff=e)),w(i.vectorProperties._Color,(i=>{t.diffuseColor=new e.Color3(i[0],i[1],i[2]),t.alpha=i[3]})),w(i.vectorProperties._ShadeColor,(i=>{t.shadeColor=new e.Color3(i[0],i[1],i[2])})),w(i.floatProperties._BumpScale,(e=>t.bumpScale=e)),w(i.floatProperties._ReceiveShadowRate,(e=>t.receiveShadowRate=e)),w(i.floatProperties._ShadingGradeRate,(e=>t.shadingGradeRate=e)),w(i.floatProperties._ShadeShift,(e=>t.shadeShift=e)),w(i.floatProperties._ShadeToony,(e=>t.shadeToony=e)),w(i.floatProperties._LightColorAttenuation,(e=>t.lightColorAttenuation=e)),w(i.floatProperties._IndirectLightIntensity,(e=>t.indirectLightIntensity=e)),w(i.vectorProperties._RimColor,(i=>{t.rimColor=new e.Color3(i[0],i[1],i[2])})),w(i.floatProperties._RimLightingMix,(e=>t.rimLightingMix=e)),w(i.floatProperties._RimFresnelPower,(e=>t.rimFresnelPower=e)),w(i.floatProperties._RimLift,(e=>t.rimLift=e)),w(i.vectorProperties._EmissionColor,(i=>{t.emissiveColor=new e.Color3(i[0],i[1],i[2])})),w(i.floatProperties._OutlineWidth,(e=>t.outlineWidth=e)),w(i.floatProperties._OutlineScaledMaxDistance,(e=>t.outlineScaledMaxDistance=e)),w(i.vectorProperties._OutlineColor,(i=>{t.outlineColor=new e.Color3(i[0],i[1],i[2])})),w(i.floatProperties._OutlineLightingMix,(e=>t.outlineLightingMix=e)),w(i.floatProperties._UvAnimScrollX,(e=>t.uvAnimationScrollX=e)),w(i.floatProperties._UvAnimScrollY,(e=>t.uvAnimationScrollY=e)),w(i.floatProperties._UvAnimRotation,(e=>t.uvAnimationRotation=e)),w(i.floatProperties._DebugMode,(e=>t.debugMode=e)),w(i.floatProperties._BlendMode,(i=>{switch(i){case 0:t.transparencyMode=e.Material.MATERIAL_OPAQUE;break;case 1:t.transparencyMode=e.Material.MATERIAL_ALPHATEST,t.alphaMode=e.Engine.ALPHA_COMBINE;break;case 2:t.transparencyMode=e.Material.MATERIAL_ALPHABLEND,t.alphaMode=e.Engine.ALPHA_COMBINE}})),w(i.floatProperties._OutlineWidthMode,(e=>t.outlineWidthMode=e)),w(i.floatProperties._OutlineColorMode,(e=>t.outlineColorMode=e)),w(i.floatProperties._CullMode,(e=>t.cullMode=e)),w(i.floatProperties._OutlineCullMode,(e=>t.outlineCullMode=e)),w(i.floatProperties._ZWrite,(e=>{t.forceDepthWrite=1===Math.round(e),t.forceDepthWrite&&(t.disableDepthWrite=!1)}))}}function w(e,t){void 0!==e&&t(e)}class U{constructor(e,t){this.loader=e,this.v3DCore=t,this.name=U.NAME,this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.loaderObservers=[],this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.addLoaderObserver(this.v3DCore),this.onLoadedCallBack=()=>{t.addVRMManager(this.manager)},t.addOnLoadCompleteCallbacks(this.onLoadedCallBack)}dispose(){this.loader=null,this.loaderObservers=[],this.v3DCore.removeOnLoadCompleteCallback(this.onLoadedCallBack)}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions[U.NAME])return;const e=this.loader.parent.uri;this.manager=new c(this.loader.gltf.extensions[U.NAME],this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,e),this.loader.babylonScene.onDisposeObservable.add((()=>{this.manager.dispose()}));for(const e of this.loaderObservers)e.onLoadReady();console.log("extension onReady")}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,o){return new y(this.loader).generate(e,t,i,n,o)}addLoaderObserver(e){this.loaderObservers.push(e)}}U.NAME="VRM";const F=LOADERS.GLTF2;class X{constructor(t,i){this.engine=t,this.scene=i,this._vrmFileLoader=new o,this._onLoadCompleteCallbacks=[],this._loadedVRMManagers=[],this.registerVrmPlugin(),this.registerVrmExtension(),this.scene?this.engine=this.scene.getEngine():this.scene=new e.Scene(this.engine),this.setupSecodaryAnimation(),this.enableResize()}addOnLoadCompleteCallbacks(e){this._onLoadCompleteCallbacks.push(e)}removeOnLoadCompleteCallback(e){const t=this._onLoadCompleteCallbacks.indexOf(e);-1!==t&&this._onLoadCompleteCallbacks.splice(t,1)}resetOnLoadCompleteCallbacks(){this._onLoadCompleteCallbacks=[]}addVRMManager(e){e&&this._loadedVRMManagers.push(e)}getVRMManagerByIndex(e){return e>=0&&e<this._loadedVRMManagers.length?this._loadedVRMManagers[e]:null}getVRMManagerByURI(e){for(const t of this._loadedVRMManagers)if(t.uri===e)return t;return null}transparentBackground(){this.scene.clearColor.a=0}solidBackground(){this.scene.clearColor.a=1}setBackgroundColor(t){this.scene.clearColor=e.Color4.FromColor3(t,this.scene.clearColor.a)}addAmbientLight(t){const i=new e.HemisphericLight("V3DHemiLight",new e.Vector3(0,1,1),this.scene);t&&(i.diffuse=t),i.setEnabled(!0)}attachCameraTo(t,i=3){const n=new e.ArcRotateCamera("V3DArcCamera"+t.cameras.length,0,0,i,t.rootMesh.position,this.scene,!0);n.lowerRadiusLimit=.1,n.upperRadiusLimit=20,n.wheelDeltaPercentage=.05,n.minZ=0,n.setPosition(new e.Vector3(0,1.5,-5)),n.setTarget(t.rootMesh.getAbsolutePosition()),n.attachControl(this.engine.getRenderingCanvas()),t.appendCamera(n)}AppendAsync(t,i){return e.SceneLoader.AppendAsync(t,i,this.scene)}LoadAsync(t,i){return e.SceneLoader.LoadAsync(t,i,this.engine)}onLoadReady(){for(const e of this._onLoadCompleteCallbacks)e()}setupSecodaryAnimation(){this.scene.onBeforeRenderObservable.add((()=>{for(const e of this._loadedVRMManagers)e.update(this.engine.getDeltaTime())}))}enableResize(){this.engine.getRenderingCanvas().onresize=()=>{this.engine.resize()}}registerVrmExtension(){F.GLTFLoader.RegisterExtension(U.NAME,(e=>new U(e,this)))}registerVrmPlugin(){e.SceneLoader&&e.SceneLoader.RegisterPlugin(this._vrmFileLoader)}}const V=X})(),window["v3d-core"]=n})();