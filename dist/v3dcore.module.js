!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["v3d-core"]=t():e["v3d-core"]=t()}(self,(function(){return(()=>{"use strict";var e,t={9802:(e,t,i)=>{i.r(t),i.d(t,{V3DCore:()=>fe,V3DHelper:()=>me});var n=i(3528),o=i(5897),r=i(6388),a=i(108),s=i(976);class l extends s.ey{constructor(){super(...arguments),this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}},this.vrmManager=null}createPlugin(){return new l}loadAsync(e,t,i,n,o){return this.uri=i,o&&(this.uri+=o),super.loadAsync(e,t,i,n,o)}}class d{constructor(e,t){this.offset=e,this.radius=t}}class h{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){this.colliders.push(new d(e,t))}}var u=i(5600),f=i(9455);class m{constructor(e,t){this.position=e,this.radius=t}}class c{static multiplyByFloat(e,t){return new a.P(e.x*t,e.y*t,e.z*t)}}class p{static multiplyWithVector3(e,t){const i=2*e.x,n=2*e.y,o=2*e.z,r=e.x*i,s=e.y*n,l=e.z*o,d=e.x*n,h=e.x*o,u=e.y*o,f=e.w*i,m=e.w*n,c=e.w*o,p=new a.P;return p.x=(1-(s+l))*t.x+(d-c)*t.y+(h+m)*t.z,p.y=(d+c)*t.x+(1-(r+l))*t.y+(u-f)*t.z,p.z=(h-m)*t.x+(u+f)*t.y+(1-(r+s))*t.z,p}static fromToRotation(e,t){const i=a.P.Cross(e,t).normalize(),n=a.P.Dot(e,t),o=e.length()*t.length(),r=Math.acos(Math.max(0,Math.min(1,n/o))),s=Math.sin(r/2);return new a._f(s*i.x,s*i.y,s*i.z,Math.cos(r/2))}}class g{constructor(e,t,i,n){this.radius=t,this.transform=i,i.rotationQuaternion||(i.rotationQuaternion=i.rotation.toQuaternion());const o=i.parent;null!==o&&null===o.rotationQuaternion&&(o.rotationQuaternion=o.rotation.toQuaternion());const r=i.getAbsolutePosition().add(n);this.centerAbsolutePos=e?e.getAbsolutePosition():new a.P(0,0,0),this.currentTail=this.getCenterTranslatedPos(r),this.prevTail=this.currentTail,this.localRotation=i.rotationQuaternion.clone(),this.boneAxis=a.P.Normalize(n),this.boneLength=n.length()}update(e,t,i,n,o){const r=this.transform.getAbsolutePosition();if(Number.isNaN(r.x))return;this.centerAbsolutePos=e?e.getAbsolutePosition():new a.P(0,0,0);const s=this.getCenterTranslatedWorldPos(this.currentTail),l=this.getCenterTranslatedWorldPos(this.prevTail);let d=s;{const e=1-i,t=c.multiplyByFloat(s.subtract(l),e);d.addInPlace(t)}{const e=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=p.multiplyWithVector3(e,this.boneAxis),n=c.multiplyByFloat(i,t);d.addInPlace(n)}d.addInPlace(n);{const e=d.subtract(r).normalize();d=r.add(c.multiplyByFloat(e,this.boneLength))}d=this.collide(o,d),this.prevTail=this.getCenterTranslatedPos(s),this.currentTail=this.getCenterTranslatedPos(d),this.setAbsoluteRotationQuaternion(this.transform,this.transformToRotation(d))}setAbsoluteRotationQuaternion(e,t){if(e.parent){const i=new a.P(0,0,0),n=new a.P(0,0,0),o=a._f.Identity(),r=a.y3.Identity();e.getWorldMatrix().decompose(n,a._f.Identity(),i),a.y3.ComposeToRef(n,t,i,r);const s=a.y3.Identity(),l=a.y3.Identity();e.parent.computeWorldMatrix(!1),e.parent.getWorldMatrix().invertToRef(l),r.multiplyToRef(l,s),s.decompose(new a.P(0,0,0),o,new a.P(0,0,0)),e.rotationQuaternion?e.rotationQuaternion.copyFrom(o):o.toEulerAnglesToRef(e.rotation)}else e.rotationQuaternion=t}getAbsoluteRotationQuaternion(e){const t=a._f.Identity();return e?.getWorldMatrix().decompose(new a.P(0,0,0),t,new a.P(0,0,0)),t}getCenterTranslatedWorldPos(e){return this.centerAbsolutePos?this.centerAbsolutePos.add(e):e}getCenterTranslatedPos(e){return this.centerAbsolutePos?e.subtract(this.centerAbsolutePos):e}transformToRotation(e){const t=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=p.multiplyWithVector3(t,this.boneAxis),n=e.subtract(this.transform.absolutePosition).normalize();return p.fromToRotation(i,n).multiplyInPlace(t)}collide(e,t){return e.forEach((e=>{const i=this.radius+e.radius,n=t.subtract(e.position);if(n.lengthSquared()<=i*i-.02){const o=e.position.add(c.multiplyByFloat(n.normalize(),i)),r=this.transform.absolutePosition;t=r.add(c.multiplyByFloat(o.subtractInPlace(r).normalize(),this.boneLength))}})),t}}class _{constructor(e,t,i,n,o,r,a,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=o,this.center=r,this.hitRadius=a,this.bones=s,this.colliderGroups=l,this.verlets=[],this.initialLocalRotations=[],this.activeBones=[],this.drawGizmo=!1,this.boneGizmoList=[],this.colliderGizmoList=[],this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{e.rotationQuaternion=e.rotationQuaternion||e.rotation.toQuaternion(),this.initialLocalRotations.push(e.rotationQuaternion.clone())}))}setup(e=!1){e||this.activeBones.forEach(((e,t)=>{e.rotationQuaternion=this.initialLocalRotations[t].clone()})),this.verlets=[],this.activeBones.forEach(((e,t)=>{this.initialLocalRotations[t]=e.rotationQuaternion,this.setupRecursive(this.center,e)}))}async update(e,t){if(0===this.verlets.length){if(0===this.activeBones.length)return;this.setup()}this.updateOptions(t);const i=[];this.colliderGroups.forEach((e=>{if(!e)return;const t=e.transform.getAbsolutePosition();Number.isNaN(t.x)||e.colliders.forEach((n=>{const o=t.add(n.offset);if(i.push(new m(o,n.radius)),this.drawGizmo){if(this.colliderGizmoList.length<i.length){const t=f.V.CreateSphere(`${e.transform.name}_colliderGizmo`,{segments:8,diameter:1,updatable:!0},e.transform.getScene()),i=new u.K(e.transform.name+"_colliderGizmomat",e.transform.getScene());i.emissiveColor=a.Wo.Yellow(),i.wireframe=!0,t.material=i,this.colliderGizmoList.push(t)}this.colliderGizmoList[i.length-1].position=o,this.colliderGizmoList[i.length-1].scaling=new a.P(2*n.radius,2*n.radius,2*n.radius)}}))}));const n=this.stiffness*e,o=c.multiplyByFloat(this.gravityDir,this.gravityPower*e),r=this.verlets.map(((e,t)=>new Promise((r=>{e.update(this.center,n,this.dragForce,o,i),this.drawGizmo&&this.boneGizmoList[t]&&(this.boneGizmoList[t].position=e.transform.absolutePosition,this.boneGizmoList[t].rotationQuaternion=e.transform.rotationQuaternion),r()}))));return Promise.all(r).then((()=>{}))}setupRecursive(e,t){if(0===t.getChildTransformNodes().length){const i=t.parent,n=t.getAbsolutePosition().subtract(i.getAbsolutePosition()).normalize(),o=t.position.add(c.multiplyByFloat(n,.07));this.verlets.push(new g(e,this.hitRadius,t,o))}else{const i=t.getChildTransformNodes().shift(),n=i.position,o=i.scaling;this.verlets.push(new g(e,this.hitRadius,t,n.multiply(o)))}if(this.drawGizmo){const e=f.V.CreateSphere(t.name+"_boneGizmo",{segments:8,diameter:2*this.hitRadius,updatable:!0},t.getScene()),i=new u.K(t.name+"_boneGizmomat",t.getScene());i.emissiveColor=a.Wo.Red(),i.wireframe=!0,e.material=i,this.boneGizmoList.push(e)}t.getChildTransformNodes().forEach((t=>{this.setupRecursive(e,t)}))}updateOptions(e){this.stiffness=e?.stiffness||this.stiffness,this.gravityPower=e?.gravityPower||this.gravityPower,this.gravityDir=e?.gravityDir||this.gravityDir,this.dragForce=e?.dragForce||this.dragForce,this.hitRadius=e?.hitRadius||this.hitRadius}}class v{constructor(e,t,i){this.ext=e;const n=this.constructColliderGroups(t);this.springs=this.constructSprings(t,n,i)}dispose(){this.springs=[]}setup(e=!1){this.springs.forEach((t=>{t.setup(e)}))}async update(e,t){e=Math.max(0,Math.min(16.666,e))/1e3;const i=this.springs.map((i=>i.update(e,t)));return Promise.all(i).then((()=>{}))}constructColliderGroups(e){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((i=>{const n=e(i.node),o=new h(n);i.colliders.forEach((e=>{o.addCollider(new a.P(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(o)})),t}constructSprings(e,t,i){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const n=[];return this.ext.boneGroups.forEach((o=>{const r=(o.bones||[]).map((t=>e(t))),s=(o.colliderGroups||[]).map((e=>t[e]));n.push(new _(o.comment,i?.stiffness?i.stiffness:o.stiffiness,i?.gravityPower?i.gravityPower:o.gravityPower,i?.gravityDir?i.gravityDir:new a.P(-o.gravityDir.x,-o.gravityDir.y,-o.gravityDir.z).normalize(),i?.dragForce?i.dragForce:o.dragForce,e(o.center),i?.hitRadius?i.hitRadius:o.hitRadius,r,s))})),n}}class A extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class M{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(e){const t=this.nodeMap[e];if(!t)throw new A(e);return t}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}class S{constructor(e,t,i){this.label=e,this.manager=i,this._value=t}get value(){return this._value}set value(e){this._value=Math.max(0,Math.min(1,e)),this.manager.morphing(this.label,e)}}class T{constructor(e,t,i,n,o){this.ext=e,this.scene=t,this.meshesFrom=i,this.transformNodesFrom=n,this.uri=o,this.morphTargetMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this._cameras=[],this.MorphTargetPropertyMap={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new v(this.ext.secondaryAnimation,this.findTransformNode.bind(this)),this.springBoneController.setup(),this.constructMorphTargetMap(),this.constructTransformNodeMap(),this._humanoidBone=new M(this.transformNodeMap),this.removeDuplicateSkeletons(),this._rootSkeleton=this.getRootSkeletonNode(),this.rootMesh.name=T.ROOT_MESH_PREFIX+this.scene.getNodes().filter((e=>e.name.includes(T.ROOT_MESH_PREFIX))).length}get cameras(){return this._cameras}appendCamera(e){this._cameras.push(e)}resetCameras(){this._cameras=[]}removeDuplicateSkeletons(){let e=null;for(const t of Object.keys(this.meshCache).map(Number)){const i=this.meshCache[t];if(i.length&&i[0].skeleton)if(e){e.bones.length!=i[0].skeleton.bones.length&&console.warn("Skeletons have different numbers of bones!"),i[0].skeleton.dispose();for(const t of i)t.skeleton=e}else if(e=i[0].skeleton,this._rootMesh){"Root"!==e.bones[0].name&&console.warn('The first bone has a different name than "Root"')}}}getRootSkeletonNode(){const e=this._rootMesh.getChildren((e=>"Root"===e.name||"Armature"===e.name));if(e.length>0)return e[0];{const e=this.scene.getNodeByName("Root")?this.scene.getNodeByName("Root"):this.scene.getNodeByName("Armature");if(e&&!e.parent)return e;throw Error("Cannot find root skeleton node!")}}async update(e,t){await this.springBoneController.update(e,t)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.MorphTargetPropertyMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}morphingPreset(e,t){this.presetMorphTargetMap[e]&&this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;let t=e.getAbsolutePosition();const i=this.ext.firstPerson.firstPersonBoneOffset;return new a.P(t.x+i.x,t.y+i.y,t.z+i.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}get rootSkeletonNode(){return this._rootSkeleton}findTransformNode(e){return this.transformNodeCache[e]||null}findMeshes(e){return this.meshCache[e]||null}constructMorphTargetMap(){this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const o=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:o,weight:t.weight}),this.MorphTargetPropertyMap[e.name]=new S(e.name,0,this),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:o,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}setShadowEnabled(e){for(const t of Object.keys(this.meshCache).map(Number)){const i=this.meshCache[t];for(const t of i)t.receiveShadows=e}}}T.ROOT_MESH_PREFIX="vrm_root_";var I=i(2067),E=i(655),x=i(8137),L=i(2186),N=i(4428),D=i(4520),C=i(2108),O=i(8494),R=i(708),b=i(4442),w=i(2869),y=i(2762);function P(){return[{label:"DiffuseColor",propertyName:"diffuseColor",type:y.r.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:y.r.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:y.r.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:y.r.Color3},{label:"RimColor",propertyName:"rimColor",type:y.r.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:y.r.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:y.r.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:y.r.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:y.r.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:y.r.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:y.r.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:y.r.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:y.r.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:y.r.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:y.r.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:y.r.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:y.r.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:y.r.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:y.r.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:y.r.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:y.r.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:y.r.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:y.r.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:y.r.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:y.r.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:y.r.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:y.r.Slider,min:-.5,max:.5,step:.01}]}var U=i(4386);class F extends U.H{constructor(){super(),this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.SPECULAR=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.SPECULARTERM=!1,this.NORMAL=!1,this.TANGENT=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.MULTIVIEW=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}var X=i(4559);class W{constructor(e,t){this.scene=e,this.material=t,this._savedDepthWrite=!1,this.name=`MToonOutline_${t.name}_${W.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine()}register(){this.scene._beforeRenderingMeshStage.registerStep(X.l.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(X.l.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){}render(e,t,i,n=!1){const o=t.effect;if(!o||!o.isReady()||!this.scene.activeCamera)return;const r=t.getMesh(),a=r._internalAbstractMeshDataInfo._actAsRegularMesh?r:null,s=t.getRenderingMesh(),l=a||s;this._engine.enableEffect(o),s._bind(t,o,this.material.fillMode),this._engine.setZOffset(-1),s._processRendering(l,t,o,this.material.fillMode,i,this.isHardwareInstancedRendering(t,i),((i,n,r)=>{r.bindForSubMesh(n,e,t),o.setMatrix("world",n),o.setFloat("isOutline",1)}),this.material),this._engine.setZOffset(0)}_beforeRenderingMesh(e,t,i){if(this._savedDepthWrite=this._engine.getDepthWrite(),!this.willRender(t))return;const n=t.getMaterial();n.needAlphaBlendingForMesh(e)&&(this._engine.cacheStencilState(),this._engine.setDepthWrite(!1),this._engine.setColorWrite(!1),this._engine.setStencilBuffer(!0),this._engine.setStencilOperationPass(O.g.REPLACE),this._engine.setStencilFunction(O.g.ALWAYS),this._engine.setStencilMask(W._StencilReference),this._engine.setStencilFunctionReference(W._StencilReference),this.render(t.getRenderingMesh(),t,i,!0),this._engine.setColorWrite(!0),this._engine.setStencilFunction(O.g.NOTEQUAL)),this._engine.setDepthWrite(!1),this.render(t.getRenderingMesh(),t,i),this._engine.setDepthWrite(this._savedDepthWrite),n.needAlphaBlendingForMesh(e)&&this._engine.restoreStencilState()}_afterRenderingMesh(e,t,i){this.willRender(t)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(t.getRenderingMesh(),t,i),this._engine.setColorWrite(!0))}isHardwareInstancedRendering(e,t){if(!this._engine.getCaps().instancedArrays)return!1;let i=!1;return i=e.getRenderingMesh().hasThinInstances,null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]||i}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}W._StencilReference=4,W.rendererId=0;var B=i(9948);const G=i(463),V=i(1486),H=i(8477),k=i(5677),z=i(7984),Y=i(8649),j=i(1854),Q=i(1483);var q,K,Z,$;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(q||(q={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(K||(K={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(Z||(Z={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}($||($={}));const J={effect:null,subMesh:null};class ee extends D.a{constructor(e,t){super(e,t),this._diffuseTexture=null,this._ambientTexture=null,this._emissiveTexture=null,this._specularTexture=null,this._bumpTexture=null,this._shadeTexture=null,this._receiveShadowTexture=null,this._shadingGradeTexture=null,this._rimTexture=null,this._matCapTexture=null,this._outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.ambientColor=new a.Wo(0,0,0),this.diffuseColor=new a.Wo(1,1,1),this.specularColor=new a.Wo(1,1,1),this.emissiveColor=new a.Wo(0,0,0),this.shadeColor=new a.Wo(.97,.81,.86),this.rimColor=new a.Wo(0,0,0),this.outlineColor=new a.Wo(0,0,0),this.specularPower=64,this._useAlphaFromDiffuseTexture=!0,this._useEmissiveAsIllumination=!1,this._linkEmissiveWithDiffuse=!1,this._useSpecularOverAlpha=!1,this._disableLighting=!1,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this.alphaCutOff=.4,this._useGlossinessFromSpecularMapAlpha=!1,this._maxSimultaneousLights=4,this._twoSidedLighting=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.detailMap=new w.p(this._markAllSubMeshesAsTexturesDirty.bind(this)),this._worldViewProjectionMatrix=a.y3.Zero(),this._globalAmbientColor=new a.Wo(0,0,0),this._bumpScale=.1,this.parallaxScaleBias=this._bumpScale,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._debugMode=q.None,this.debugMode=q.None,this.outlineRenderer=new W(this.getScene(),this),this._outlineWidthMode=Z.None,this.outlineWidthMode=Z.None,this._outlineColorMode=K.MixedLighting,this.outlineColorMode=K.MixedLighting,this._cullMode=$.Back,this._outlineCullMode=$.Front,this.outlineCullMode=$.Front,this.storedCullMode=$.Back,this.prePassConfiguration=new N.o,b.Q.ShadersStore.mtoonVertexShader&&b.Q.ShadersStore.mtoonFragmentShader||(b.Q.IncludesShadersStore.mtoonUboDeclaration=G,b.Q.IncludesShadersStore.mtoonVertexDeclaration=V,b.Q.IncludesShadersStore.mtoonFragmentDeclaration=H,b.Q.IncludesShadersStore.mtoonLightPreFragment=z,b.Q.IncludesShadersStore.mtoonLightFragment=Y,b.Q.IncludesShadersStore.mtoonBumpFragment=k,b.Q.ShadersStore.mtoonVertexShader=j,b.Q.ShadersStore.mtoonFragmentShader=Q),this.inspectableCustomProperties=this.inspectableCustomProperties?this.inspectableCustomProperties.concat(P()):P()}appendedActiveTextures(){return[this._diffuseTexture,this._ambientTexture,this._emissiveTexture,this._specularTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture].filter((e=>null!==e))}get isPrePassCapable(){return!0}get canRenderToMRT(){return!1}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case $.Off:this.backFaceCulling=!1,this.sideOrientation=I.F.ClockWiseSideOrientation,this.twoSidedLighting=!0;break;case $.Front:this.backFaceCulling=!0,this.sideOrientation=I.F.CounterClockWiseSideOrientation,this.twoSidedLighting=!1;break;case $.Back:this.backFaceCulling=!0,this.sideOrientation=I.F.ClockWiseSideOrientation,this.twoSidedLighting=!1}this.markAsDirty(I.F.TextureDirtyFlag)}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported,this._markAllSubMeshesAsMiscDirty()}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===I.F.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==I.F.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){if(t.effect&&this.isFrozen&&t.effect._wasPreviouslyReady)return!0;t._materialDefines||(t.materialDefines=new F);const n=this.getScene(),o=t._materialDefines;if(this._isReadyForSubMesh(t))return!0;const r=n.getEngine();if(o._needNormals=C.G.PrepareDefinesForLights(n,e,o,!0,this._maxSimultaneousLights,this._disableLighting)||this.outlineWidthMode!==Z.None,C.G.PrepareDefinesForMultiview(n,o),C.G.PrepareDefinesForPrePass(n,o,this.canRenderToMRT),o._areTexturesDirty){this.applyDefines(o),o._needUVs=!1;for(let e=1;e<=O.g.MAX_SUPPORTED_UV_SETS;++e)o["MAINUV"+e]=!1;if(n.texturesEnabled){if(this._diffuseTexture&&ee.DiffuseTextureEnabled){if(!this._diffuseTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._diffuseTexture,o,"DIFFUSE")}else o.DIFFUSE=!1;if(this._ambientTexture&&ee.AmbientTextureEnabled){if(!this._ambientTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._ambientTexture,o,"AMBIENT")}else o.AMBIENT=!1;if(this._emissiveTexture&&ee.EmissiveTextureEnabled){if(!this._emissiveTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._emissiveTexture,o,"EMISSIVE")}else o.EMISSIVE=!1;if(this._specularTexture&&ee.SpecularTextureEnabled){if(!this._specularTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._specularTexture,o,"SPECULAR"),o.GLOSSINESS=this._useGlossinessFromSpecularMapAlpha}else o.SPECULAR=!1;if(n.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;C.G.PrepareDefinesForMergedUV(this._bumpTexture,o,"BUMP"),o.PARALLAX=this._useParallax,o.PARALLAXOCCLUSION=this._useParallaxOcclusion,o.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap}else o.BUMP=!1;if(this._shadeTexture){if(!this._shadeTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._shadeTexture,o,"SHADE")}else o.SHADE=!1;if(this._receiveShadowTexture){if(!this._receiveShadowTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._receiveShadowTexture,o,"RECEIVE_SHADOW")}else o.RECEIVE_SHADOW=!1;if(this._shadingGradeTexture){if(!this._shadingGradeTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._shadingGradeTexture,o,"SHADING_GRADE")}else o.SHADING_GRADE=!1;if(this._rimTexture){if(!this._rimTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._rimTexture,o,"RIM")}else o.RIM=!1;if(this._matCapTexture){if(!this._matCapTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._matCapTexture,o,"MATCAP")}else o.MATCAP=!1;if(this._outlineWidthTexture){if(!this._outlineWidthTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._outlineWidthTexture,o,"OUTLINE_WIDTH")}else o.OUTLINE_WIDTH=!1;if(this._uvAnimationMaskTexture){if(!this._uvAnimationMaskTexture.isReadyOrNotBlocking())return!1;C.G.PrepareDefinesForMergedUV(this._uvAnimationMaskTexture,o,"UV_ANIMATION_MASK")}else o.UV_ANIMATION_MASK=!1;o.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else o.DIFFUSE=!1,o.AMBIENT=!1,o.EMISSIVE=!1,o.BUMP=!1,o.SHADE=!1,o.RECEIVE_SHADOW=!1,o.SHADING_GRADE=!1,o.RIM=!1,o.MATCAP=!1,o.OUTLINE_WIDTH=!1,o.UV_ANIMATION_MASK=!1;o.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),o.EMISSIVEASILLUMINATION=this._useEmissiveAsIllumination,o.LINKEMISSIVEWITHDIFFUSE=this._linkEmissiveWithDiffuse,o.SPECULAROVERALPHA=this._useSpecularOverAlpha,o.PREMULTIPLYALPHA=this.alphaMode===O.g.ALPHA_PREMULTIPLIED||this.alphaMode===O.g.ALPHA_PREMULTIPLIED_PORTERDUFF,o.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,o.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(!this.detailMap.isReadyForSubMesh(o,n))return!1;if(C.G.PrepareDefinesForMisc(e,n,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e)||this._forceAlphaTest,o),C.G.PrepareDefinesForAttributes(e,o,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),C.G.PrepareDefinesForFrameBoundValues(n,r,o,i,null,t.getRenderingMesh().hasThinInstances),this.detailMap.prepareDefines(o,n),o.isDirty){const i=o._areLightsDisposed;o.markAsProcessed();const a=new R.L;o.SPECULAR&&a.addFallback(0,"SPECULAR"),o.BUMP&&a.addFallback(0,"BUMP"),o.PARALLAX&&a.addFallback(1,"PARALLAX"),o.PARALLAXOCCLUSION&&a.addFallback(0,"PARALLAXOCCLUSION"),o.SPECULAROVERALPHA&&a.addFallback(0,"SPECULAROVERALPHA"),o.FOG&&a.addFallback(1,"FOG"),o.POINTSIZE&&a.addFallback(0,"POINTSIZE"),o.LOGARITHMICDEPTH&&a.addFallback(0,"LOGARITHMICDEPTH"),C.G.HandleFallbacksForShadows(o,a,this._maxSimultaneousLights),o.SPECULARTERM&&a.addFallback(0,"SPECULARTERM"),o.MULTIVIEW&&a.addFallback(0,"MULTIVIEW");const s=[L.o.PositionKind];o.NORMAL&&s.push(L.o.NormalKind),o.TANGENT&&s.push(L.o.TangentKind);for(let e=1;e<=O.g.MAX_SUPPORTED_UV_SETS;++e)o["UV"+e]&&s.push(`uv${1===e?"":e}`);o.VERTEXCOLOR&&s.push(L.o.ColorKind),C.G.PrepareAttributesForBones(s,e,o,a),C.G.PrepareAttributesForInstances(s,o),C.G.PrepareAttributesForMorphTargets(s,e,o);let l="mtoon";const d=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","visibility","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","diffuseMatrix","ambientMatrix","emissiveMatrix","specularMatrix","bumpMatrix","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","morphTargetTextureInfo","morphTargetTextureIndices"],h=["diffuseSampler","ambientSampler","emissiveSampler","specularSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler","morphTargets"],u=["Material","Scene"];w.p.AddUniforms(d),w.p.AddSamplers(h),N.o.AddUniforms(d),N.o.AddSamplers(h),C.G.PrepareUniformsAndSamplersList({uniformsNames:d,uniformBuffersNames:u,samplers:h,defines:o,maxSimultaneousLights:this._maxSimultaneousLights});const f={};this.customShaderNameResolve&&(l=this.customShaderNameResolve(l,d,u,h,o,s,f));const m=o.toString(),c=t.effect;let p=n.getEngine().createEffect(l,{attributes:s,uniformsNames:d,uniformBuffersNames:u,samplers:h,defines:m,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:o.NUM_MORPH_INFLUENCERS},processFinalCode:f.processFinalCode,multiTarget:o.PREPASS},r);if(p)if(this._onEffectCreatedObservable&&(J.effect=p,J.subMesh=t,this._onEffectCreatedObservable.notifyObservers(J)),this.allowShaderHotSwapping&&c&&!p.isReady()){if(p=c,o.markAsUnprocessed(),i)return o._areLightsDisposed=!0,!1}else n.resetCachedMaterial(),t.setEffect(p,o,this._materialContext),this.buildUniformLayout()}return!(!t.effect||!t.effect.isReady())&&(o._renderId=n.getRenderId(),t.effect._wasPreviouslyReady=!0,!0)}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vSpecularColor",4),e.addUniform("vSpecularInfos",2),e.addUniform("specularMatrix",16),e.addUniform("vAmbientColor",3),e.addUniform("vAmbientInfos",2),e.addUniform("ambientMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("alphaCutOff",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),w.p.PrepareUniformBuffer(e),e.create()}unbind(){super.unbind()}bindForSubMesh(e,t,i){const n=this.getScene(),r=i._materialDefines;if(!r)return;const s=i.effect;if(!s)return;this._activeEffect=s,t.getMeshUniformBuffer().bindToEffect(s,"Mesh"),t.transferToEffect(e),this.prePassConfiguration.bindForSubMesh(this._activeEffect,n,t,e,this.isFrozen),r.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const l=this._mustRebind(n,s,t.visibility);C.G.BindBonesParameters(t,s);const d=this._uniformBuffer;l&&(d.bindToEffect(s,"Material"),this.bindViewProjection(s),d.useUbo&&this.isFrozen&&d.isSync||n.texturesEnabled&&(this._diffuseTexture&&ee.DiffuseTextureEnabled&&(d.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),C.G.BindTextureMatrix(this._diffuseTexture,d,"diffuse")),this._ambientTexture&&ee.AmbientTextureEnabled&&(d.updateFloat2("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level),C.G.BindTextureMatrix(this._ambientTexture,d,"ambient")),this._hasAlphaChannel()&&d.updateFloat("alphaCutOff",this.alphaCutOff),this._emissiveTexture&&ee.EmissiveTextureEnabled&&(d.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),C.G.BindTextureMatrix(this._emissiveTexture,d,"emissive")),this._specularTexture&&ee.SpecularTextureEnabled&&(d.updateFloat2("vSpecularInfos",this._specularTexture.coordinatesIndex,this._specularTexture.level),C.G.BindTextureMatrix(this._specularTexture,d,"specular")),this._bumpTexture&&n.getEngine().getCaps().standardDerivatives&&ee.BumpTextureEnabled&&(d.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this.parallaxScaleBias),C.G.BindTextureMatrix(this._bumpTexture,d,"bump"),n._mirroredCameraPosition?d.updateFloat2("vTangentSpaceParams",-1,-1):d.updateFloat2("vTangentSpaceParams",1,1)),this._shadeTexture&&(d.updateFloat2("vShadeInfos",this._shadeTexture.coordinatesIndex,this._shadeTexture.level),C.G.BindTextureMatrix(this._shadeTexture,d,"shade")),this._receiveShadowTexture&&(d.updateFloat2("vReceiveShadowInfos",this._receiveShadowTexture.coordinatesIndex,this._receiveShadowTexture.level),C.G.BindTextureMatrix(this._receiveShadowTexture,d,"receiveShadow")),this._shadingGradeTexture&&(d.updateFloat2("vShadingGradeInfos",this._shadingGradeTexture.coordinatesIndex,this._shadingGradeTexture.level),C.G.BindTextureMatrix(this._shadingGradeTexture,d,"shadingGrade")),this._rimTexture&&(d.updateFloat2("vRimInfos",this._rimTexture.coordinatesIndex,this._rimTexture.level),C.G.BindTextureMatrix(this._rimTexture,d,"rim")),this._matCapTexture&&(d.updateFloat2("vMatCapInfos",this._matCapTexture.coordinatesIndex,this._matCapTexture.level),C.G.BindTextureMatrix(this._matCapTexture,d,"matCap")),this._outlineWidthTexture&&(d.updateFloat2("vOutlineWidthInfos",this._outlineWidthTexture.coordinatesIndex,this._outlineWidthTexture.level),C.G.BindTextureMatrix(this._outlineWidthTexture,d,"outlineWidth")),this._uvAnimationMaskTexture&&(d.updateFloat2("vUvAnimationMaskInfos",this._uvAnimationMaskTexture.coordinatesIndex,this._uvAnimationMaskTexture.level),C.G.BindTextureMatrix(this._uvAnimationMaskTexture,d,"uvAnimationMask"))),this.pointsCloud&&d.updateFloat("pointSize",this.pointSize),r.SPECULARTERM&&d.updateColor4("vSpecularColor",this.specularColor,this.specularPower),d.updateColor3("vEmissiveColor",this.emissiveColor),d.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),n.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),d.updateColor3("vAmbientColor",this._globalAmbientColor),d.updateFloat("receiveShadowRate",this._receiveShadowRate),d.updateFloat("shadingGradeRate",this._shadingGradeRate),d.updateFloat("shadeShift",this._shadeShift),d.updateFloat("shadeToony",this._shadeToony),d.updateFloat("lightColorAttenuation",this._lightColorAttenuation),d.updateFloat("indirectLightIntensity",this._indirectLightIntensity),d.updateFloat("rimLightingMix",this._rimLightingMix),d.updateFloat("rimFresnelPower",this._rimFresnelPower),d.updateFloat("rimLift",this._rimLift),d.updateFloat("outlineWidth",this._outlineWidth),d.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),d.updateFloat("outlineLightingMix",this._outlineLightingMix),d.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),d.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),d.updateFloat("uvAnimationRotation",this._uvAnimationRotation),n.texturesEnabled&&(this._diffuseTexture&&ee.DiffuseTextureEnabled&&s.setTexture("diffuseSampler",this._diffuseTexture),this._ambientTexture&&ee.AmbientTextureEnabled&&s.setTexture("ambientSampler",this._ambientTexture),this._emissiveTexture&&ee.EmissiveTextureEnabled&&s.setTexture("emissiveSampler",this._emissiveTexture),this._specularTexture&&ee.SpecularTextureEnabled&&s.setTexture("specularSampler",this._specularTexture),this._bumpTexture&&n.getEngine().getCaps().standardDerivatives&&ee.BumpTextureEnabled&&s.setTexture("bumpSampler",this._bumpTexture),this._shadeTexture&&s.setTexture("shadeSampler",this._shadeTexture),this._receiveShadowTexture&&s.setTexture("receiveShadowSampler",this._receiveShadowTexture),this._shadingGradeTexture&&s.setTexture("shadingGradeSampler",this._shadingGradeTexture),this._rimTexture&&s.setTexture("rimSampler",this._rimTexture),this._matCapTexture&&s.setTexture("matCapSampler",this._matCapTexture),this._outlineWidthTexture&&s.setTexture("outlineWidthSampler",this._outlineWidthTexture),this._uvAnimationMaskTexture&&s.setTexture("uvAnimationMaskSampler",this._uvAnimationMaskTexture)),this.detailMap.bindForSubMesh(d,n,this.isFrozen),C.G.BindClipPlane(s,n),this.bindEyePosition(s),s.setVector3("vEyeUp",n.activeCamera.upVector),d.updateColor3("vShadeColor",this.shadeColor),d.updateColor3("vRimColor",this.rimColor),d.updateColor4("vOutlineColor",this.outlineColor,1)),!l&&this.isFrozen||(n.lightsEnabled&&!this._disableLighting&&C.G.BindLights(n,t,s,r,this._maxSimultaneousLights),(n.fogEnabled&&t.applyFog&&n.fogMode!==o.x.FOGMODE_NONE||t.receiveShadows)&&this.bindView(s),C.G.BindFogParameters(n,t,s),r.NUM_MORPH_INFLUENCERS&&C.G.BindMorphTargetParameters(t,s),this.useLogarithmicDepth&&C.G.BindLogDepth(r,s,n)),s.setFloat("aspect",n.getEngine().getAspectRatio(n.activeCamera)),s.setFloat("isOutline",0);const h=window.performance.now()/1e3;s.setVector4("time",new a.Lt(h/20,h,2*h,3*h)),this._afterBind(t,this._activeEffect),d.update()}getAnimatables(){const e=[];for(const t of this.appendedActiveTextures())t.animations&&t.animations.length>0&&e.push(t);return this.detailMap.getAnimatables(e),e}getActiveTextures(){const e=super.getActiveTextures().concat(this.appendedActiveTextures());return this.detailMap.getActiveTextures(e),e}hasTexture(e){if(super.hasTexture(e))return!0;const t=this.appendedActiveTextures();return t.length>0?t.some((t=>t===e)):this.detailMap.hasTexture(e)}dispose(e,t){t&&this.appendedActiveTextures().forEach((e=>e.dispose())),this.detailMap.dispose(t),super.dispose(e,t)}applyDefines(e){switch(this._debugMode){case q.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case q.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case q.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this._outlineWidthMode){case Z.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case Z.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case Z.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this._outlineColorMode){case K.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case K.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}clone(e){const t=x.p4.Clone((()=>new ee(e,this.getScene())),this);return t.name=e,t.id=e,this.stencil.copyTo(t.stencil),t}serialize(){const e=x.p4.Serialize(this);return e.stencil=this.stencil.serialize(),e}static Parse(e,t,i){const n=x.p4.Parse((()=>new ee(e.name,t)),e,t,i);return e.stencil&&n.stencil.parse(e.stencil,t,i),n}static get DiffuseTextureEnabled(){return B.k6g.DiffuseTextureEnabled}static set DiffuseTextureEnabled(e){B.k6g.DiffuseTextureEnabled=e}static get AmbientTextureEnabled(){return B.k6g.AmbientTextureEnabled}static set AmbientTextureEnabled(e){B.k6g.AmbientTextureEnabled=e}static get EmissiveTextureEnabled(){return B.k6g.EmissiveTextureEnabled}static set EmissiveTextureEnabled(e){B.k6g.EmissiveTextureEnabled=e}static get SpecularTextureEnabled(){return B.k6g.SpecularTextureEnabled}static set SpecularTextureEnabled(e){B.k6g.SpecularTextureEnabled=e}static get BumpTextureEnabled(){return B.k6g.BumpTextureEnabled}static set BumpTextureEnabled(e){B.k6g.BumpTextureEnabled=e}}var te;(0,E.gn)([(0,x.oU)("diffuseTexture")],ee.prototype,"_diffuseTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"diffuseTexture",void 0),(0,E.gn)([(0,x.oU)("ambientTexture")],ee.prototype,"_ambientTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"ambientTexture",void 0),(0,E.gn)([(0,x.oU)("emissiveTexture")],ee.prototype,"_emissiveTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"emissiveTexture",void 0),(0,E.gn)([(0,x.oU)("specularTexture")],ee.prototype,"_specularTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"specularTexture",void 0),(0,E.gn)([(0,x.oU)("bumpTexture")],ee.prototype,"_bumpTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"bumpTexture",void 0),(0,E.gn)([(0,x.oU)("shadeTexture")],ee.prototype,"_shadeTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"shadeTexture",void 0),(0,E.gn)([(0,x.oU)("receiveShadowTexture")],ee.prototype,"_receiveShadowTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"receiveShadowTexture",void 0),(0,E.gn)([(0,x.oU)("shadingGradeTexture")],ee.prototype,"_shadingGradeTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"shadingGradeTexture",void 0),(0,E.gn)([(0,x.oU)("rimTexture")],ee.prototype,"_rimTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"rimTexture",void 0),(0,E.gn)([(0,x.oU)("matCapTexture")],ee.prototype,"_matCapTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"matCapTexture",void 0),(0,E.gn)([(0,x.oU)("outlineWidthTexture")],ee.prototype,"_outlineWidthTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"outlineWidthTexture",void 0),(0,E.gn)([(0,x.oU)("uvAnimationMaskTexture")],ee.prototype,"_uvAnimationMaskTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"uvAnimationMaskTexture",void 0),(0,E.gn)([(0,x.n9)("ambient")],ee.prototype,"ambientColor",void 0),(0,E.gn)([(0,x.n9)("diffuse")],ee.prototype,"diffuseColor",void 0),(0,E.gn)([(0,x.n9)("specular")],ee.prototype,"specularColor",void 0),(0,E.gn)([(0,x.n9)("emissive")],ee.prototype,"emissiveColor",void 0),(0,E.gn)([(0,x.n9)("shade")],ee.prototype,"shadeColor",void 0),(0,E.gn)([(0,x.n9)("rim")],ee.prototype,"rimColor",void 0),(0,E.gn)([(0,x.n9)("outline")],ee.prototype,"outlineColor",void 0),(0,E.gn)([(0,x.qC)()],ee.prototype,"specularPower",void 0),(0,E.gn)([(0,x.qC)("useAlphaFromDiffuseTexture")],ee.prototype,"_useAlphaFromDiffuseTexture",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"useAlphaFromDiffuseTexture",void 0),(0,E.gn)([(0,x.qC)("useEmissiveAsIllumination")],ee.prototype,"_useEmissiveAsIllumination",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useEmissiveAsIllumination",void 0),(0,E.gn)([(0,x.qC)("linkEmissiveWithDiffuse")],ee.prototype,"_linkEmissiveWithDiffuse",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"linkEmissiveWithDiffuse",void 0),(0,E.gn)([(0,x.qC)("useSpecularOverAlpha")],ee.prototype,"_useSpecularOverAlpha",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useSpecularOverAlpha",void 0),(0,E.gn)([(0,x.qC)("disableLighting")],ee.prototype,"_disableLighting",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"disableLighting",void 0),(0,E.gn)([(0,x.qC)("useObjectSpaceNormalMap")],ee.prototype,"_useObjectSpaceNormalMap",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useObjectSpaceNormalMap",void 0),(0,E.gn)([(0,x.qC)("useParallax")],ee.prototype,"_useParallax",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useParallax",void 0),(0,E.gn)([(0,x.qC)("useParallaxOcclusion")],ee.prototype,"_useParallaxOcclusion",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useParallaxOcclusion",void 0),(0,E.gn)([(0,x.qC)()],ee.prototype,"alphaCutOff",void 0),(0,E.gn)([(0,x.qC)("useGlossinessFromSpecularMapAlpha")],ee.prototype,"_useGlossinessFromSpecularMapAlpha",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useGlossinessFromSpecularMapAlpha",void 0),(0,E.gn)([(0,x.qC)("maxSimultaneousLights")],ee.prototype,"_maxSimultaneousLights",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"maxSimultaneousLights",void 0),(0,E.gn)([(0,x.qC)("twoSidedLighting")],ee.prototype,"_twoSidedLighting",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"twoSidedLighting",void 0),(0,E.gn)([(0,x.qC)("bumpScale")],ee.prototype,"_bumpScale",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"bumpScale",void 0),(0,E.gn)([(0,x.qC)()],ee.prototype,"parallaxScaleBias",void 0),(0,E.gn)([(0,x.qC)("receiveShadowRate")],ee.prototype,"_receiveShadowRate",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"receiveShadowRate",void 0),(0,E.gn)([(0,x.qC)("shadingGradeRate")],ee.prototype,"_shadingGradeRate",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadingGradeRate",void 0),(0,E.gn)([(0,x.qC)("shadeShift")],ee.prototype,"_shadeShift",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadeShift",void 0),(0,E.gn)([(0,x.qC)("shadeToony")],ee.prototype,"_shadeToony",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadeToony",void 0),(0,E.gn)([(0,x.qC)("lightColorAttenuation")],ee.prototype,"_lightColorAttenuation",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"lightColorAttenuation",void 0),(0,E.gn)([(0,x.qC)("indirectLightIntensity")],ee.prototype,"_indirectLightIntensity",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"indirectLightIntensity",void 0),(0,E.gn)([(0,x.qC)("rimLightingMix")],ee.prototype,"_rimLightingMix",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimLightingMix",void 0),(0,E.gn)([(0,x.qC)("rimFresnelPower")],ee.prototype,"_rimFresnelPower",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimFresnelPower",void 0),(0,E.gn)([(0,x.qC)("rimLift")],ee.prototype,"_rimLift",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimLift",void 0),(0,E.gn)([(0,x.qC)("outlineWidth")],ee.prototype,"_outlineWidth",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineWidth",void 0),(0,E.gn)([(0,x.qC)("outlineScaledMaxDistance")],ee.prototype,"_outlineScaledMaxDistance",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineScaledMaxDistance",void 0),(0,E.gn)([(0,x.qC)("outlineLightingMix")],ee.prototype,"_outlineLightingMix",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineLightingMix",void 0),(0,E.gn)([(0,x.qC)("uvAnimationScrollX")],ee.prototype,"_uvAnimationScrollX",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationScrollX",void 0),(0,E.gn)([(0,x.qC)("uvAnimationScrollY")],ee.prototype,"_uvAnimationScrollY",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationScrollY",void 0),(0,E.gn)([(0,x.qC)("uvAnimationRotation")],ee.prototype,"_uvAnimationRotation",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationRotation",void 0),(0,E.gn)([(0,x.qC)("debugMode")],ee.prototype,"_debugMode",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"debugMode",void 0),(0,E.gn)([(0,x.qC)("outlineWidthMode")],ee.prototype,"_outlineWidthMode",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineWidthMode",void 0),(0,E.gn)([(0,x.qC)("outlineColorMode")],ee.prototype,"_outlineColorMode",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineColorMode",void 0),(0,E.gn)([(0,x.qC)("cullMode")],ee.prototype,"_cullMode",void 0),(0,E.gn)([(0,x.qC)("outlineCullMode")],ee.prototype,"_outlineCullMode",void 0),(0,E.gn)([(0,x.wz)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineCullMode",void 0),(0,E.gn)([(0,x.qC)()],ee.prototype,"useLogarithmicDepth",null),B.QeW.RegisteredTypes["BABYLON.MToonMaterial"]=ee,function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(te||(te={}));var ie=i(8838);class ne{constructor(e){this.loader=e}generate(e,t,i,n,o){const r=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!r)return null;i.alphaIndex=r.renderQueue;const a=this.createMaterialByShader(e,t,n,r);return a?(o(a),a instanceof ee?this.loadMToonTexturesAsync(e,a,r):Promise.resolve(a)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],o=i.vectorProperties._MainTex;if(!o)return Promise.resolve(t);const r=(t,i)=>{oe(t,(r=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:r},(e=>{const t=e;t.uOffset=o[0],t.vOffset=o[1],t.uScale=o[2],t.vScale=o[3],i(e)})))}))};return r(i.textureProperties._MainTex,(e=>{t.diffuseTexture=e,t.transparencyMode&&(t.diffuseTexture.hasAlpha=!0)})),r(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),r(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),r(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),r(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),r(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),r(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),r(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),r(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),r(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===te.VRMMToon){const e=new ee(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===te.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){oe(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),oe(t.vectorProperties._Color,(t=>{e.diffuseColor=new a.Wo(t[0],t[1],t[2]),e.alpha=t[3]})),oe(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new a.Wo(t[0],t[1],t[2])})),oe(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),oe(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),oe(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),oe(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),oe(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),oe(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),oe(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),oe(t.vectorProperties._RimColor,(t=>{e.rimColor=new a.Wo(t[0],t[1],t[2])})),oe(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),oe(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),oe(t.floatProperties._RimLift,(t=>e.rimLift=t)),oe(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new a.Wo(t[0],t[1],t[2])})),oe(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),oe(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),oe(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new a.Wo(t[0],t[1],t[2])})),oe(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),oe(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),oe(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),oe(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),oe(t.floatProperties._DebugMode,(t=>e.debugMode=t)),oe(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.transparencyMode=I.F.MATERIAL_OPAQUE;break;case 1:e.transparencyMode=I.F.MATERIAL_ALPHATEST,e.alphaMode=ie.D.ALPHA_COMBINE;break;case 2:e.transparencyMode=I.F.MATERIAL_ALPHABLEND,e.alphaMode=ie.D.ALPHA_COMBINE}})),oe(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),oe(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),oe(t.floatProperties._CullMode,(t=>e.cullMode=t)),oe(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),oe(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function oe(e,t){void 0!==e&&t(e)}class re{constructor(e,t){this.loader=e,this.v3DCore=t,this.name=re.NAME,this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.loaderObservers=[],this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.addLoaderObserver(this.v3DCore),this.onLoadedCallBack=()=>{t.addVRMManager(this.manager)},t.addOnLoadCompleteCallbacks(this.onLoadedCallBack)}dispose(){this.loader=null,this.loaderObservers=[],this.v3DCore.removeOnLoadCompleteCallback(this.onLoadedCallBack)}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions[re.NAME])return;const e=this.loader.parent.uri;this.manager=new T(this.loader.gltf.extensions[re.NAME],this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,e),this.loader.babylonScene.onDisposeObservable.add((()=>{this.manager.dispose()}));for(const e of this.loaderObservers)e.onLoadReady();console.log("extension onReady")}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,o){return new ne(this.loader).generate(e,t,i,n,o)}addLoaderObserver(e){this.loaderObservers.push(e)}}re.NAME="VRM";var ae=i(126),se=i(2587);function le(e){return void 0!==e.setShadowProjectionMatrix}class de{constructor(e){this.scene=e,this._options=de.CustomOptimizerOptions(),this._optimizer=new B.GY9(e,this._options),this._optimizer.targetFrameRate=fe.FRAMERATE,this._optimizer.trackerDuration=2e3,this._optimizer.start(),this.setupFocusEvents(this._optimizer)}get options(){return this._options}set options(e){this._options=e}get optimizer(){return this._optimizer}static CustomOptimizerOptions(){const e=new B.ywH;return e.addOptimization(new B.a8K(0)),e.addOptimization(new B.ZQh(1)),e.addOptimization(new B.Zqg(2,512)),e.addOptimization(new B.oeA(3)),e.addOptimization(new B.frz(4,2)),e}setupFocusEvents(e){window&&(console.log("setupFocusEvents"),window.addEventListener("focusin",(function(t){console.log("Optimizer start"),e.start()}),!0),window.addEventListener("focusout",(function(t){console.log("Optimizer stop"),e.stop(),e.reset()}),!0))}}var he=i(1413);class ue{constructor(e,t,i,n){this.scene=e,this.textureName=t,this.boxSize=i,this.envTexture=n,this._skybox=B.Kj0.CreateBox("Skybox",i,this.scene,void 0,B.Kj0.BACKSIDE),this._skyboxBase=B.Kj0.CreateBox("SkyboxBase",i+1,this.scene,void 0,B.Kj0.BACKSIDE),this.createMaterial(t),this._skybox.material=this.skyboxMaterial,this._skyboxBase.material=this.skyboxBaseMaterial,this._skybox.renderingGroupId=0,this._skyboxBase.renderingGroupId=0,this._skybox.material.transparencyMode=B.F5T.MATERIAL_ALPHATESTANDBLEND,this._skybox.material.alpha=.5,this.setupImageProcessing()}get skybox(){return this._skybox}createMaterial(e){this.skyboxBaseMaterial=new he.fE("SkyboxBaseMaterial",this.scene),this.skyboxMaterial=new B.Iij("SkyboxMaterial",this.scene),this.skyboxMaterial.backFaceCulling=!1,this.skyboxMaterial.useRGBColor=!1,this.skyboxMaterial.primaryColor=new B.Wot(1,1,1),this.skyboxMaterial.enableNoise=!0,this.skyboxReflectionTexture=new B.BtG(e,this.scene),this.skyboxReflectionTexture.coordinatesMode=B.xEZ.SKYBOX_MODE,this.skyboxReflectionTexture.gammaSpace=!1,this.skyboxMaterial.reflectionTexture=this.skyboxReflectionTexture}setupImageProcessing(){this.scene.imageProcessingConfiguration.contrast=1.2,this.scene.imageProcessingConfiguration.exposure=.8,this.scene.imageProcessingConfiguration.toneMappingEnabled=!0,this.scene.environmentTexture=this.envTexture?this.envTexture:B.BtG.CreateFromPrefilteredData(ue._environmentTextureCDNUrl,this.scene)}}ue._environmentTextureCDNUrl="https://assets.babylonjs.com/environments/environmentSpecular.env";class fe{constructor(e,t,i){this.engine=e,this.scene=t,this._vrmFileLoader=new l,this._shadowGenerators=new Map,this._onLoadCompleteCallbacks=[],this._managerRenderFunc=()=>{for(const e of this.loadedVRMManagers)e.update(this.engine.getDeltaTime())},this._cameraOnBeforeRenderFunc=[],this.skyBox=null,this.loadedVRMManagers=[],this.registerVrmPlugin(),this.registerVrmExtension(),this.scene?this.engine=this.scene.getEngine():this.scene=new o.x(this.engine),this.setupSecodaryAnimation(),this.enableResize(),i?(this._mainCamera=i,this.scene.switchActiveCamera(i)):this.addCamera(),this._renderingPipeline=new B.eiL("defaultPipeline",!0,this.scene,[this._mainCamera]),this.setupRenderingPipeline()}get renderingPipeline(){return this._renderingPipeline}addOnLoadCompleteCallbacks(e){this._onLoadCompleteCallbacks.push(e)}removeOnLoadCompleteCallback(e){const t=this._onLoadCompleteCallbacks.indexOf(e);-1!==t&&this._onLoadCompleteCallbacks.splice(t,1)}resetOnLoadCompleteCallbacks(){this._onLoadCompleteCallbacks=[]}updateManagerRenderFunction(e){this._managerRenderFunc=e}get mainCamera(){return this._mainCamera}set mainCamera(e){this._mainCamera=e}addVRMManager(e){e&&this.loadedVRMManagers.push(e)}getVRMManagerByIndex(e){return e>=0&&e<this.loadedVRMManagers.length?this.loadedVRMManagers[e]:null}getVRMManagerByURI(e){for(const t of this.loadedVRMManagers)if(t.uri===e)return t;return null}transparentBackground(){this.scene.clearColor.a=0}solidBackground(){this.scene.clearColor.a=1}setBackgroundColor(e){this.scene.clearColor=a.HE.FromColor3(e,this.scene.clearColor.a).toLinearSpace()}addAmbientLight(e){const t=new se.e("V3DHemiLight",new a.P(0,1,1),this.scene);e&&(t.diffuse=e),t.setEnabled(!0)}addCamera(e=3){const t=new n.Y("V3DMainCamera",0,0,e,new a.P(0,0,0),this.scene,!0);t.lowerRadiusLimit=.1,t.upperRadiusLimit=20,t.wheelDeltaPercentage=.05,t.minZ=0,t.setPosition(new a.P(0,1.5,-5)),t.attachControl(this.engine.getRenderingCanvas()),this._mainCamera=t,this.scene.switchActiveCamera(this._mainCamera,!0)}attachCameraTo(e,t=3){const i=new n.Y("V3DArcCamera"+e.cameras.length,0,0,t,e.rootMesh.position,this.scene,!0);i.lowerRadiusLimit=.1,i.upperRadiusLimit=20,i.wheelDeltaPercentage=.05,i.minZ=0,i.setPosition(new a.P(0,1.5,-5)),i.setTarget(e.rootMesh.getAbsolutePosition()),i.attachControl(this.engine.getRenderingCanvas()),e.appendCamera(i),this._cameraOnBeforeRenderFunc.push((()=>{i.setTarget(e.rootMesh.getAbsolutePosition())}))}createSkyBox(e,t){this.skyBox||(this.skyBox=new ue(this.scene,t||"texture/skybox",e))}enableShabows(e){if(e)if(this._shadowGenerators.has(e))console.warn("Light "+e.name+" already has a shadow generator!");else{const t=new B.uXA(1024,e);this.setupShadowGenerator(t),this._shadowGenerators.set(e,t)}else for(const e of this.scene.lights)if(le(e)){const t=new B.uXA(1024,e);this.setupShadowGenerator(t),this._shadowGenerators.set(e,t)}}getShadownGenerator(e){return this._shadowGenerators.get(e)}startQuickAnimation(e,t,i,n,o,r,a,s,l){const d=this.createAnimation(e,t,i,[{frame:0,value:o},{frame:n,value:r}],a,s,l);return this.scene.beginDirectAnimation(d[0],[d[1]],0,n,!1)}createAnimation(e,t,i,n,o,r,s){if(n.length<1)throw Error("Key Frames empty");const l=function(e){let t;return!isNaN(parseFloat(e))&&isFinite(e)?t=B.fwF.ANIMATIONTYPE_FLOAT:e instanceof a._f?t=B.fwF.ANIMATIONTYPE_QUATERNION:e instanceof a.P?t=B.fwF.ANIMATIONTYPE_VECTOR3:e instanceof a.FM?t=B.fwF.ANIMATIONTYPE_VECTOR2:e instanceof a.Wo?t=B.fwF.ANIMATIONTYPE_COLOR3:e instanceof a.HE?t=B.fwF.ANIMATIONTYPE_COLOR4:e instanceof a.$u&&(t=B.fwF.ANIMATIONTYPE_SIZE),null==t?null:t}(n[0].value);if(null===l)throw Error("Cannot determine data type from keyframes!");const d=new B.fwF(t,i,fe.FRAMERATE,l,o);return d.setKeys(n),r&&(s&&r.setEasingMode(s),d.setEasingFunction(r)),[e,d]}enableOptimizer(){this._sceneOptimizer=new de(this.scene)}AppendAsync(e,t){return r.n.AppendAsync(e,t,this.scene)}LoadAsync(e,t){return r.n.LoadAsync(e,t,this.engine)}onLoadReady(){for(const e of this._onLoadCompleteCallbacks)e()}setupSecodaryAnimation(){this.scene.onBeforeRenderObservable.add(((e,t)=>{this._managerRenderFunc(e,t)})),this.scene.onBeforeRenderObservable.add((()=>{for(const e of this._cameraOnBeforeRenderFunc)e()}))}enableResize(){this.engine.getRenderingCanvas().onresize=()=>{this.engine.resize()}}setupShadowGenerator(e){e.usePercentageCloserFiltering=!0,e.filteringQuality=B.uXA.QUALITY_HIGH}registerVrmExtension(){ae.EP.RegisterExtension(re.NAME,(e=>new re(e,this)))}registerVrmPlugin(){r.n&&r.n.RegisterPlugin(this._vrmFileLoader)}setupRenderingPipeline(){this._renderingPipeline.samples=4,this._renderingPipeline.depthOfFieldEnabled=!0,this._renderingPipeline.depthOfFieldBlurLevel=B.zmM.Medium,this._renderingPipeline.depthOfField.focusDistance=2e3,this._renderingPipeline.depthOfField.focalLength=10,this._renderingPipeline.depthOfField.fStop=1.4}}fe.FRAMERATE=60;class me{constructor(e){this.core=e}addNodeToShadowCasterByName(e,t){e.addShadowCaster(this.core.scene.getNodeByName(t))}addNodeToShadowCasterContainsName(e,t){for(const i of this.core.scene.getNodes())i&&i.name.includes(t)&&e.addShadowCaster(i)}makeReceiveShadowByName(e){this.core.scene.getNodeByName(e).receiveShadows=!0}makeReceiveShadowContainsName(e){for(const t of this.core.scene.getNodes())if(t&&t.name.includes(e))try{t.receiveShadows=!0}catch(e){console.log(e)}}showSkeletonDebug(e,t){const i={pauseAnimations:!0,returnToRest:!1,computeBonesUsingShaders:!0,useAllBones:!0,displayMode:B.McK.DISPLAY_LINES};return new B.McK(e,t,this.core.scene,!0,t.renderingGroupId>0?t.renderingGroupId+1:1,i)}}},655:(e,t,i)=>{i.d(t,{ZT:()=>o,pi:()=>r,gn:()=>a,mG:()=>s,Jh:()=>l,ev:()=>d});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var n=function(e,t){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])},n(e,t)};function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function i(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(i.prototype=t.prototype,new i)}var r=function(){return r=Object.assign||function(e){for(var t,i=1,n=arguments.length;i<n;i++)for(var o in t=arguments[i])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},r.apply(this,arguments)};function a(e,t,i,n){var o,r=arguments.length,a=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(o=e[s])&&(a=(r<3?o(a):r>3?o(t,i,a):o(t,i))||a);return r>3&&a&&Object.defineProperty(t,i,a),a}function s(e,t,i,n){return new(i||(i=Promise))((function(o,r){function a(e){try{l(n.next(e))}catch(e){r(e)}}function s(e){try{l(n.throw(e))}catch(e){r(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(a,s)}l((n=n.apply(e,t||[])).next())}))}function l(e,t){var i,n,o,r,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return r={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function s(r){return function(s){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,n&&(o=2&r[0]?n.return:r[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,r[1])).done)return o;switch(n=0,o&&(r=[2&r[0],o.value]),r[0]){case 0:case 1:o=r;break;case 4:return a.label++,{value:r[1],done:!1};case 5:a.label++,n=r[1],r=[0];continue;case 7:r=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==r[0]&&2!==r[0])){a=0;continue}if(3===r[0]&&(!o||r[1]>o[0]&&r[1]<o[3])){a.label=r[1];break}if(6===r[0]&&a.label<o[1]){a.label=o[1],o=r;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(r);break}o[2]&&a.ops.pop(),a.trys.pop();continue}r=t.call(e,a)}catch(e){r=[6,e],n=0}finally{i=o=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,s])}}}Object.create;function d(e,t,i){if(i||2===arguments.length)for(var n,o=0,r=t.length;o<r;o++)!n&&o in t||(n||(n=Array.prototype.slice.call(t,0,o)),n[o]=t[o]);return e.concat(n||Array.prototype.slice.call(t))}Object.create},5677:e=>{e.exports="// replace vBumpUV with mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        vec2 TBNUV=gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n"},8477:e=>{e.exports="uniform vec4 vEyePosition;\nuniform mat4 viewProjection;\nuniform mat4 view;\n\n// Colors\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n"},7984:e=>{e.exports="#ifdef LIGHT{X}\n/**\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n    #else\n        #ifdef PBR\n\n            #ifdef SPOTLIGHT{X}\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #endif\n            preInfo.NdotV=NdotV;\n\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation=1.0;\n            #endif\n\n\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness=roughness;\n            #else\n                preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n            #endif\n\n            #ifdef HEMILIGHT{X}\n                info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n            #else\n               info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                   info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #else\n                   info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n\n                   preInfo.roughness=sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                      preInfo.roughness=sheenOut.sheenRoughness;\n                    #else\n                      preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef CLEARCOAT\n\n                #ifdef HEMILIGHT{X}\n                  preInfo.roughness=clearcoatOut.clearCoatRoughness;\n                #else\n                  preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                #endif\n                info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n                #ifdef CLEARCOAT_TINT\n\n                    absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\n                    info.diffuse*=absorption;\n                    #ifdef SPECULARTERM\n                        info.specular*=absorption;\n                    #endif\n                #endif\n\n                info.diffuse*=info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular*=info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen*=info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #elif defined(HEMILIGHT{X})\n                info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #endif\n        #endif\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n        #endif\n    #endif\n*/\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n                #else\n                    diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X}>=0.) {\n                    index{X}=i;\n                    break;\n                }\n            }\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X}>=0)\n            #endif\n            {\n            #if defined(SHADOWPCF{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #else\n                    shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #endif\n            #elif defined(SHADOWPCSS{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #else\n                    shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #endif\n            #else\n                shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n            #endif\n            #ifdef SHADOWCSMDEBUG{X}\n                shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n            #endif\n            #ifndef SHADOWCSMNOBLEND{X}\n                float frustumLength=frustumLengths{X}[index{X}];\n                float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\n                if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n                {\n                    index{X}+=1;\n                    float nextShadow=0.;\n                    #if defined(SHADOWPCF{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #else\n                            nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #endif\n                    #elif defined(SHADOWPCSS{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #else\n                            nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #endif\n                    #else\n                        nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                    #endif\n                    shadow=mix(nextShadow,shadow,diffRatio);\n                    #ifdef SHADOWCSMDEBUG{X}\n                        shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n                    #endif\n                }\n            #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow+=shadow;\n            shadowLightCount+=1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n/**\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n            #ifdef SPECULARTERM\n                specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase+=lightmapColor.rgb*shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase+=info.specular*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase+=info.sheen.rgb*shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase+=info.diffuse*shadowDebug{X};\n            #else\n                diffuseBase+=info.diffuse*shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase+=info.specular*shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase+=info.clearCoat.rgb*shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase+=info.sheen.rgb*shadow;\n            #endif\n        #endif\n    #endif\n*/\n\n    //  MToon \n    #ifdef SPOTLIGHT{X}\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\n    #elif defined(HEMILIGHT{X})\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n        lightDirection = computeLightDirection(light{X}.vLightData);\n    #endif\n    computeDirectLight(normalW.xyz, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n#endif\n"},8649:e=>{e.exports="#ifdef LIGHT{X}\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n    diffuseBase += mtoonDiffuse.rgb;\n    alpha = min(alpha, mtoonDiffuse.a);\n    #if defined(ALPHATEST) && ALPHATEST\n        alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n        if (alpha < alphaCutOff) {\n            discard;\n        }\n        alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n    #else\n        if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n            discard;\n        }\n    #endif\n#endif\n"},1483:e=>{e.exports="#include<__decl__mtoonFragment>\n\n#if defined(BUMP) || !defined(NORMAL) || (defined(ALPHATEST) && ALPHATEST)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n#define MAX_NUM_LIGHTS 16\n\n//uniform vec3 vEyePosition;\n//uniform vec3 vAmbientColor;\n//#ifdef ALPHATEST\n//uniform float alphaCutOff;\n//#endif\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float isOutline;\nuniform vec4 time;\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n/**\n* DirectionalLight, PointLight \n*/\nvec3 computeLightDirection(vec4 lightData) {\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* SpotLight \n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n     return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* HemisphericLight \n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n     return normalize(lightData.xyz);\n}\n\n/**\n* MToon \n*/\n//#define MTOON_FORWARD_ADD\n/**\n* Calculate light seoarately\n*/\nint realNumLights = 0;\nvec3 totalDirectLighting = vec3(0.);\nvec3 directLightingArr[MAX_NUM_LIGHTS] = vec3[MAX_NUM_LIGHTS](\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.)\n);\nvoid computeDirectLight(vec3 worldNormal, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    realNumLights += 1;\n    float _dotNL = dot(lightDirection, worldNormal);\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n    #ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0., _dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n    #else\n    // base light does not darken.\n    // Make material receive shadow.\n    _lighting *= shadowAttenuation;\n    #endif\n\n    // Compress total light\n    directLightingArr[realNumLights] = _lighting;\n    totalDirectLighting += _lighting;\n}\n\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    realNumLights += 1;\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    float _dotNL = dot(lightDirection, worldNormal);\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lightingGain = totalDirectLighting/float(realNumLights);\n    _lightingGain = sinh(_lightingGain / 2.);\n    vec3 _lighting = directLightingArr[realNumLights] * _lightingGain;\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb * _lightingGain;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting * _lightingGain, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting * _lightingGain, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n     _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n     _col += mix(_emission * _lightingGain, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n// debug\n//#define MTOON_DEBUG_LITSHADERATE\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lightIntensity, _lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n    #define CUSTOM_FRAGMENT_MAIN_BEGIN\n    #ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n        #ifdef MTOON_OUTLINE_WIDTH_WORLD\n        #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n        #else\n            discard;\n        #endif\n    #endif\n\n    #include<clipPlaneFragment>\n    vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n\n    // Base color\n    // Strangely MToon decided to use base diffuse color as light color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n//    vec3 diffuseColor=vDiffuseColor.rgb;\n\n    // Alpha\n    float alpha = 1.0;\n//    float alpha = vDiffuseColor.a;\n\n// Bump\n#ifdef NORMAL\n     vec3 normalW = normalize(vNormalW);\n#else\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n\n// MToon UV\n//  diffuse(_MainTex)  UV \nvec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#elif defined(MAINUV3)\n    mainUv += vMainUV3;\n#elif defined(MAINUV4)\n    mainUv += vMainUV4;\n#elif defined(MAINUV5)\n    mainUv += vMainUV5;\n#elif defined(MAINUV6)\n    mainUv += vMainUV6;\n#endif\n\n// UV animation\nfloat uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\nuvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n// Translate UV in bottom-left origin coordinates.\n// UV is reversed\nmainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n\n// Rotate UV counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\nfloat rotateRad = uvAnimationRotation * PI_2 * uvAnim;\nvec2 rotatePivot = vec2(0.5, 0.5);\nmainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#include<mtoonBumpFragment>\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n#ifdef DIFFUSE\n//    baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n    #if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\n        if (baseColor.a<alphaCutOff)\n            discard;\n    #endif\n    #ifdef ALPHAFROMDIFFUSE\n        alpha*=baseColor.a;\n    #endif\n    #define CUSTOM_FRAGMENT_UPDATE_ALPHA\n    baseColor.rgb*=vDiffuseInfos.y;\n#endif\n\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\n// Ambient color\nvec3 baseAmbientColor = vec3(1., 1., 1.);\n#ifdef AMBIENT\n    baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\n    float glossiness=vSpecularColor.a;\n    vec3 specularColor=vSpecularColor.rgb;\n    #ifdef SPECULAR\n        vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\n        specularColor=specularMapColor.rgb;\n        #ifdef GLOSSINESS\n            glossiness=glossiness*specularMapColor.a;\n        #endif\n    #endif\n#else\n    float glossiness=0.;\n#endif\n\n// Lighting\nvec3 diffuseBase = vec3(0., 0., 0.);\nlightingInfo info;\n#ifdef SPECULARTERM\n    vec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow = 1.;\nvec3 lightDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n//  lightFragment  mtoonLightFragment \n#include<mtoonLightPreFragment>[0..maxSimultaneousLights]\nrealNumLights = 0;    // reset light count\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n#ifdef VERTEXALPHA\n    alpha*=vColor.a;\n#endif\n\n#ifdef ALPHATEST\n    #ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\n        if (alpha<alphaCutOff)\n            discard;\n    #endif\n    #ifndef ALPHABLEND\n        alpha=1.0;\n    #endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor.rgb;\n// MToon use emissive texture in a non-standard way\n//#ifdef EMISSIVE\n//    emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n//#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n    #ifdef LINKEMISSIVEWITHDIFFUSE\n        vec3 finalDiffuse=clamp((diffuseBase)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #else\n        vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #endif\n#endif\n#ifdef SPECULARTERM\n    vec3 finalSpecular=specularBase*specularColor;\n    #ifdef SPECULAROVERALPHA\n        alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n    #endif\n#else\n    vec3 finalSpecular=vec3(0.0);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular,0.0,1.0),alpha);\n#else\n    vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular,alpha);\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor=color;\n#endif\n}\n"},1854:e=>{e.exports="//  include  UboDeclaration  VertexDeclaration \n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n//  default.vertex.fx \n\n// Attributes\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n\n// Additional Uniforms\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\nuniform float aspect;\nuniform float isOutline;\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n\n// Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n\nfloat outlineTex = 1.0;\nif (isOutline == 1.0) {\n#include<samplerVertexImplementation>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_MATRIXNAME_,outlineWidth,_INFONAME_,OutlineWidthInfos.x)\n#ifdef OUTLINE_WIDTH\n    #if defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #elif defined(MAINUV3)\n        vec2 vOutlineWidthUV = vMainUV3;\n    #elif defined(MAINUV4)\n        vec2 vOutlineWidthUV = vMainUV4;\n    #elif defined(MAINUV5)\n        vec2 vOutlineWidthUV = vMainUV5;\n    #elif defined(MAINUV6)\n        vec2 vOutlineWidthUV = vMainUV6;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n    outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n    //  normal \n    vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\n    positionUpdated.xyz += outlineOffset;\n#endif\n} // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\n        vNormalW=normalize(normalWorld*vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n    vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n    if (isOutline == 1.0) {\n        vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\n        projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n        projectedNormal.x *= aspect;\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy * clamp(\n            1.0 - abs(normalize(view * vec4(normalUpdated, 1.0)).z), 0.0, 1.0); // ignore offset when normal toward camera\n    }\n#endif\n\n    if (isOutline == 1.0) {\n        gl_Position.z += 1E-2 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,UvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n"},463:e=>{e.exports="// include<__decl__mtoonVertex>  include<__decl__mtoonFragment>  WebGL2 \n// @see effect.ts\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vSpecularColor;\n    vec2 vSpecularInfos;\n    mat4 specularMatrix;\n    vec3 vAmbientColor;\n    vec2 vAmbientInfos;\n    mat4 ambientMatrix;\n    vec3 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n    float alphaCutOff;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n};\n\n// babylon specific\nuniform Scene {\n    mat4 viewProjection;\n#ifdef MULTIVIEW\n    mat4 viewProjectionR;\n#endif\n    mat4 view;\n    mat4 projection;\n    vec4 vEyePosition;\n};\n"},1486:e=>{e.exports="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n"}},i={};function n(e){var o=i[e];if(void 0!==o)return o.exports;var r=i[e]={exports:{}};return t[e](r,r.exports,n),r.exports}n.m=t,e=[],n.O=(t,i,o,r)=>{if(!i){var a=1/0;for(h=0;h<e.length;h++){for(var[i,o,r]=e[h],s=!0,l=0;l<i.length;l++)(!1&r||a>=r)&&Object.keys(n.O).every((e=>n.O[e](i[l])))?i.splice(l--,1):(s=!1,r<a&&(a=r));if(s){e.splice(h--,1);var d=o();void 0!==d&&(t=d)}}return t}r=r||0;for(var h=e.length;h>0&&e[h-1][2]>r;h--)e[h]=e[h-1];e[h]=[i,o,r]},n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e={76:0};n.O.j=t=>0===e[t];var t=(t,i)=>{var o,r,[a,s,l]=i,d=0;if(a.some((t=>0!==e[t]))){for(o in s)n.o(s,o)&&(n.m[o]=s[o]);if(l)var h=l(n)}for(t&&t(i);d<a.length;d++)r=a[d],n.o(e,r)&&e[r]&&e[r][0](),e[a[d]]=0;return n.O(h)},i=self.webpackChunkv3d_core=self.webpackChunkv3d_core||[];i.forEach(t.bind(null,0)),i.push=t.bind(null,i.push.bind(i))})();var o=n.O(void 0,[874],(()=>n(9802)));return o=n.O(o)})()}));