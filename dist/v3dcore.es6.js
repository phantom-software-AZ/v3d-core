import*as e from"@babylonjs/materials";var t={677:e=>{e.exports="// replace vBumpUV with mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        vec2 TBNUV=gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n"},477:e=>{e.exports="uniform vec4 vEyePosition;\nuniform mat4 viewProjection;\nuniform mat4 view;\n\n// Colors\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n"},984:e=>{e.exports="#ifdef LIGHT{X}\n/**\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n    #else\n        #ifdef PBR\n\n            #ifdef SPOTLIGHT{X}\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n            #endif\n            preInfo.NdotV=NdotV;\n\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                    preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                    preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation=1.0;\n            #endif\n\n\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness=roughness;\n            #else\n                preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n            #endif\n\n            #ifdef HEMILIGHT{X}\n                info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n            #else\n               info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                   info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #else\n                   info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n\n                   preInfo.roughness=sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                      preInfo.roughness=sheenOut.sheenRoughness;\n                    #else\n                      preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n            #endif\n\n            #ifdef CLEARCOAT\n\n                #ifdef HEMILIGHT{X}\n                  preInfo.roughness=clearcoatOut.clearCoatRoughness;\n                #else\n                  preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n                #endif\n                info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n                #ifdef CLEARCOAT_TINT\n\n                    absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\n                    info.diffuse*=absorption;\n                    #ifdef SPECULARTERM\n                        info.specular*=absorption;\n                    #endif\n                #endif\n\n                info.diffuse*=info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular*=info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen*=info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #elif defined(HEMILIGHT{X})\n                info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n            #endif\n        #endif\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n        #endif\n    #endif\n*/\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n                #else\n                    diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X}>=0.) {\n                    index{X}=i;\n                    break;\n                }\n            }\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X}>=0)\n            #endif\n            {\n            #if defined(SHADOWPCF{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #else\n                    shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                #endif\n            #elif defined(SHADOWPCSS{X})\n                #if defined(SHADOWLOWQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #elif defined(SHADOWMEDIUMQUALITY{X})\n                    shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #else\n                    shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                #endif\n            #else\n                shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n            #endif\n            #ifdef SHADOWCSMDEBUG{X}\n                shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n            #endif\n            #ifndef SHADOWCSMNOBLEND{X}\n                float frustumLength=frustumLengths{X}[index{X}];\n                float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\n                if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n                {\n                    index{X}+=1;\n                    float nextShadow=0.;\n                    #if defined(SHADOWPCF{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #else\n                            nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                        #endif\n                    #elif defined(SHADOWPCSS{X})\n                        #if defined(SHADOWLOWQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #elif defined(SHADOWMEDIUMQUALITY{X})\n                            nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #else\n                            nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n                        #endif\n                    #else\n                        nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n                    #endif\n                    shadow=mix(nextShadow,shadow,diffRatio);\n                    #ifdef SHADOWCSMDEBUG{X}\n                        shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n                    #endif\n                }\n            #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow+=shadow;\n            shadowLightCount+=1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n/**\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n            #ifdef SPECULARTERM\n                specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase+=lightmapColor.rgb*shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase+=info.specular*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase+=info.sheen.rgb*shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase+=info.diffuse*shadowDebug{X};\n            #else\n                diffuseBase+=info.diffuse*shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase+=info.specular*shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase+=info.clearCoat.rgb*shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase+=info.sheen.rgb*shadow;\n            #endif\n        #endif\n    #endif\n*/\n\n    // ここで MToon のライティングを適用\n    #ifdef SPOTLIGHT{X}\n        lightDirection = computeSpotLightDirection(light{X}.vLightData);\n    #elif defined(HEMILIGHT{X})\n        lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n    #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n        lightDirection = computeLightDirection(light{X}.vLightData);\n    #endif\n    computeDirectLight(normalW.xyz, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n#endif\n"},649:e=>{e.exports="#ifdef LIGHT{X}\n    mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n    diffuseBase += mtoonDiffuse.rgb;\n    alpha = min(alpha, mtoonDiffuse.a);\n    #if defined(ALPHATEST) && ALPHATEST\n        alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n        if (alpha < alphaCutOff) {\n            discard;\n        }\n        alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n    #else\n        if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n            discard;\n        }\n    #endif\n#endif\n"},483:e=>{e.exports="#include<__decl__mtoonFragment>\n\n#if defined(BUMP) || !defined(NORMAL) || (defined(ALPHATEST) && ALPHATEST)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n#define MAX_NUM_LIGHTS 16\n\n//uniform vec3 vEyePosition;\n//uniform vec3 vAmbientColor;\n//#ifdef ALPHATEST\n//uniform float alphaCutOff;\n//#endif\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float isOutline;\nuniform vec4 time;\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n/**\n* DirectionalLight, PointLight の角度を計算\n*/\nvec3 computeLightDirection(vec4 lightData) {\n      return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* SpotLight の角度を計算\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n     return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* HemisphericLight の角度を計算\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n     return normalize(lightData.xyz);\n}\n\n/**\n* MToon シェーダーの陰実装\n*/\n//#define MTOON_FORWARD_ADD\n/**\n* Calculate light seoarately\n*/\nint realNumLights = 0;\nvec3 totalDirectLighting = vec3(0.);\nvec3 directLightingArr[MAX_NUM_LIGHTS] = vec3[MAX_NUM_LIGHTS](\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.),\n    vec3(0.), vec3(0.), vec3(0.), vec3(0.)\n);\nvoid computeDirectLight(vec3 worldNormal, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    realNumLights += 1;\n    float _dotNL = dot(lightDirection, worldNormal);\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n    #ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0., _dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n    #else\n    // base light does not darken.\n    // Make material receive shadow.\n    _lighting *= shadowAttenuation;\n    #endif\n\n    // Compress total light\n    directLightingArr[realNumLights] = _lighting;\n    totalDirectLighting += _lighting;\n}\n\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    realNumLights += 1;\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    float _dotNL = dot(lightDirection, worldNormal);\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lightingGain = totalDirectLighting/float(realNumLights);\n    _lightingGain = sinh(_lightingGain / 2.);\n    vec3 _lighting = directLightingArr[realNumLights] * _lightingGain;\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb * _lightingGain;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting * _lightingGain, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting * _lightingGain, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n     _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n     _col += mix(_emission * _lightingGain, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n// debug\n//#define MTOON_DEBUG_LITSHADERATE\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lightIntensity, _lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n    #define CUSTOM_FRAGMENT_MAIN_BEGIN\n    #ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n        #ifdef MTOON_OUTLINE_WIDTH_WORLD\n        #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n        #else\n            discard;\n        #endif\n    #endif\n\n    #include<clipPlaneFragment>\n    vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n\n    // Base color\n    // Strangely MToon decided to use base diffuse color as light color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n//    vec3 diffuseColor=vDiffuseColor.rgb;\n\n    // Alpha\n    float alpha = 1.0;\n//    float alpha = vDiffuseColor.a;\n\n// Bump\n#ifdef NORMAL\n     vec3 normalW = normalize(vNormalW);\n#else\n     vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n\n// MToon UV\n// 全てのテクスチャは diffuse(_MainTex) の UV 情報を利用する\nvec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#elif defined(MAINUV3)\n    mainUv += vMainUV3;\n#elif defined(MAINUV4)\n    mainUv += vMainUV4;\n#elif defined(MAINUV5)\n    mainUv += vMainUV5;\n#elif defined(MAINUV6)\n    mainUv += vMainUV6;\n#endif\n\n// UV animation\nfloat uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\nuvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n// Translate UV in bottom-left origin coordinates.\n// UV is reversed\nmainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n\n// Rotate UV counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\nfloat rotateRad = uvAnimationRotation * PI_2 * uvAnim;\nvec2 rotatePivot = vec2(0.5, 0.5);\nmainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#include<mtoonBumpFragment>\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n#ifdef DIFFUSE\n//    baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n    #if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\n        if (baseColor.a<alphaCutOff)\n            discard;\n    #endif\n    #ifdef ALPHAFROMDIFFUSE\n        alpha*=baseColor.a;\n    #endif\n    #define CUSTOM_FRAGMENT_UPDATE_ALPHA\n    baseColor.rgb*=vDiffuseInfos.y;\n#endif\n\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\n// Ambient color\nvec3 baseAmbientColor = vec3(1., 1., 1.);\n#ifdef AMBIENT\n    baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\n    float glossiness=vSpecularColor.a;\n    vec3 specularColor=vSpecularColor.rgb;\n    #ifdef SPECULAR\n        vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\n        specularColor=specularMapColor.rgb;\n        #ifdef GLOSSINESS\n            glossiness=glossiness*specularMapColor.a;\n        #endif\n    #endif\n#else\n    float glossiness=0.;\n#endif\n\n// Lighting\nvec3 diffuseBase = vec3(0., 0., 0.);\nlightingInfo info;\n#ifdef SPECULARTERM\n    vec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow = 1.;\nvec3 lightDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n// 通常の lightFragment ではなく、自前実装の mtoonLightFragment を読み込む\n#include<mtoonLightPreFragment>[0..maxSimultaneousLights]\nrealNumLights = 0;    // reset light count\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n#ifdef VERTEXALPHA\n    alpha*=vColor.a;\n#endif\n\n#ifdef ALPHATEST\n    #ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\n        if (alpha<alphaCutOff)\n            discard;\n    #endif\n    #ifndef ALPHABLEND\n        alpha=1.0;\n    #endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor.rgb;\n// MToon use emissive texture in a non-standard way\n//#ifdef EMISSIVE\n//    emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n//#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n    #ifdef LINKEMISSIVEWITHDIFFUSE\n        vec3 finalDiffuse=clamp((diffuseBase)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #else\n        vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n    #endif\n#endif\n#ifdef SPECULARTERM\n    vec3 finalSpecular=specularBase*specularColor;\n    #ifdef SPECULAROVERALPHA\n        alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n    #endif\n#else\n    vec3 finalSpecular=vec3(0.0);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\n    vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular,0.0,1.0),alpha);\n#else\n    vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular,alpha);\n#endif\n\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor=color;\n#endif\n}\n"},854:e=>{e.exports="// この include は特別で、 UboDeclaration または VertexDeclaration のどちらかに置換される\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// 基本的に default.vertex.fx を踏襲している\n\n// Attributes\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n\n// Additional Uniforms\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\nuniform float aspect;\nuniform float isOutline;\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\n    varying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\n    varying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n\n// Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n\nfloat outlineTex = 1.0;\nif (isOutline == 1.0) {\n#include<samplerVertexImplementation>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_MATRIXNAME_,outlineWidth,_INFONAME_,OutlineWidthInfos.x)\n#ifdef OUTLINE_WIDTH\n    #if defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #elif defined(MAINUV3)\n        vec2 vOutlineWidthUV = vMainUV3;\n    #elif defined(MAINUV4)\n        vec2 vOutlineWidthUV = vMainUV4;\n    #elif defined(MAINUV5)\n        vec2 vOutlineWidthUV = vMainUV5;\n    #elif defined(MAINUV6)\n        vec2 vOutlineWidthUV = vMainUV6;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n    outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n    // ワールド座標の normal 分だけ移動する\n    vec3 outlineOffset = normalize(finalWorld * vec4(normalUpdated, 1.0)).xyz * 0.01 * outlineWidth * outlineTex;\n    positionUpdated.xyz += outlineOffset;\n#endif\n} // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\n        vNormalW=normalize(normalWorld*vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n    vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n    if (isOutline == 1.0) {\n        vec4 projectedNormal = normalize(viewProjection * finalWorld * vec4(normalUpdated, 1.0));\n        projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n        projectedNormal.x *= aspect;\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy * clamp(\n            1.0 - abs(normalize(view * vec4(normalUpdated, 1.0)).z), 0.0, 1.0); // ignore offset when normal toward camera\n    }\n#endif\n\n    if (isOutline == 1.0) {\n        gl_Position.z += 1E-2 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,UvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\n\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n"},463:e=>{e.exports="// include<__decl__mtoonVertex> または include<__decl__mtoonFragment> と書いた時に WebGL2 の場合展開される\n// @see effect.ts\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vSpecularColor;\n    vec2 vSpecularInfos;\n    mat4 specularMatrix;\n    vec3 vAmbientColor;\n    vec2 vAmbientInfos;\n    mat4 ambientMatrix;\n    vec3 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n    float alphaCutOff;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n};\n\n// babylon specific\nuniform Scene {\n    mat4 viewProjection;\n#ifdef MULTIVIEW\n    mat4 viewProjectionR;\n#endif\n    mat4 view;\n    mat4 projection;\n    vec4 vEyePosition;\n};\n"},486:e=>{e.exports="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n"}},i={};function n(e){var r=i[e];if(void 0!==r)return r.exports;var o=i[e]={exports:{}};return t[e](o,o.exports,n),o.exports}n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var r={};(()=>{n.d(r,{M:()=>fe,L:()=>ce});const t=(e=>{var t={};return n.d(t,e),t})({ArcRotateCamera:()=>e.ArcRotateCamera});const i=(e=>{var t={};return n.d(t,e),t})({Scene:()=>e.Scene});const o=(e=>{var t={};return n.d(t,e),t})({SceneLoader:()=>e.SceneLoader});const a=(e=>{var t={};return n.d(t,e),t})({Color3:()=>e.Color3,Color4:()=>e.Color4,Matrix:()=>e.Matrix,Quaternion:()=>e.Quaternion,Size:()=>e.Size,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4});const s=(e=>{var t={};return n.d(t,e),t})({GLTFFileLoader:()=>e.GLTFFileLoader});class l extends s.GLTFFileLoader{constructor(){super(...arguments),this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}},this.vrmManager=null}createPlugin(){return new l}loadAsync(e,t,i,n,r){return this.uri=i,r&&(this.uri+=r),super.loadAsync(e,t,i,n,r)}}class d{constructor(e,t){this.offset=e,this.radius=t}}class h{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){this.colliders.push(new d(e,t))}}const u=(e=>{var t={};return n.d(t,e),t})({StandardMaterial:()=>e.StandardMaterial});const f=(e=>{var t={};return n.d(t,e),t})({MeshBuilder:()=>e.MeshBuilder});class c{constructor(e,t){this.position=e,this.radius=t}}class m{static multiplyByFloat(e,t){return new a.Vector3(e.x*t,e.y*t,e.z*t)}}class p{static multiplyWithVector3(e,t){const i=2*e.x,n=2*e.y,r=2*e.z,o=e.x*i,s=e.y*n,l=e.z*r,d=e.x*n,h=e.x*r,u=e.y*r,f=e.w*i,c=e.w*n,m=e.w*r,p=new a.Vector3;return p.x=(1-(s+l))*t.x+(d-m)*t.y+(h+c)*t.z,p.y=(d+m)*t.x+(1-(o+l))*t.y+(u-f)*t.z,p.z=(h-c)*t.x+(u+f)*t.y+(1-(o+s))*t.z,p}static fromToRotation(e,t){const i=a.Vector3.Cross(e,t).normalize(),n=a.Vector3.Dot(e,t),r=e.length()*t.length(),o=Math.acos(Math.max(0,Math.min(1,n/r))),s=Math.sin(o/2);return new a.Quaternion(s*i.x,s*i.y,s*i.z,Math.cos(o/2))}}class g{constructor(e,t,i,n){this.radius=t,this.transform=i,i.rotationQuaternion||(i.rotationQuaternion=i.rotation.toQuaternion());const r=i.parent;null!==r&&null===r.rotationQuaternion&&(r.rotationQuaternion=r.rotation.toQuaternion());const o=i.getAbsolutePosition().add(n);this.centerAbsolutePos=e?e.getAbsolutePosition():new a.Vector3(0,0,0),this.currentTail=this.getCenterTranslatedPos(o),this.prevTail=this.currentTail,this.localRotation=i.rotationQuaternion.clone(),this.boneAxis=a.Vector3.Normalize(n),this.boneLength=n.length()}update(e,t,i,n,r){const o=this.transform.getAbsolutePosition();if(Number.isNaN(o.x))return;this.centerAbsolutePos=e?e.getAbsolutePosition():new a.Vector3(0,0,0);const s=this.getCenterTranslatedWorldPos(this.currentTail),l=this.getCenterTranslatedWorldPos(this.prevTail);let d=s;{const e=1-i,t=m.multiplyByFloat(s.subtract(l),e);d.addInPlace(t)}{const e=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=p.multiplyWithVector3(e,this.boneAxis),n=m.multiplyByFloat(i,t);d.addInPlace(n)}d.addInPlace(n);{const e=d.subtract(o).normalize();d=o.add(m.multiplyByFloat(e,this.boneLength))}d=this.collide(r,d),this.prevTail=this.getCenterTranslatedPos(s),this.currentTail=this.getCenterTranslatedPos(d),this.setAbsoluteRotationQuaternion(this.transform,this.transformToRotation(d))}setAbsoluteRotationQuaternion(e,t){if(e.parent){const i=new a.Vector3(0,0,0),n=new a.Vector3(0,0,0),r=a.Quaternion.Identity(),o=a.Matrix.Identity();e.getWorldMatrix().decompose(n,a.Quaternion.Identity(),i),a.Matrix.ComposeToRef(n,t,i,o);const s=a.Matrix.Identity(),l=a.Matrix.Identity();e.parent.computeWorldMatrix(!1),e.parent.getWorldMatrix().invertToRef(l),o.multiplyToRef(l,s),s.decompose(new a.Vector3(0,0,0),r,new a.Vector3(0,0,0)),e.rotationQuaternion?e.rotationQuaternion.copyFrom(r):r.toEulerAnglesToRef(e.rotation)}else e.rotationQuaternion=t}getAbsoluteRotationQuaternion(e){const t=a.Quaternion.Identity();return e?.getWorldMatrix().decompose(new a.Vector3(0,0,0),t,new a.Vector3(0,0,0)),t}getCenterTranslatedWorldPos(e){return this.centerAbsolutePos?this.centerAbsolutePos.add(e):e}getCenterTranslatedPos(e){return this.centerAbsolutePos?e.subtract(this.centerAbsolutePos):e}transformToRotation(e){const t=this.getAbsoluteRotationQuaternion(this.transform.parent).multiply(this.localRotation),i=p.multiplyWithVector3(t,this.boneAxis),n=e.subtract(this.transform.absolutePosition).normalize();return p.fromToRotation(i,n).multiplyInPlace(t)}collide(e,t){return e.forEach((e=>{const i=this.radius+e.radius,n=t.subtract(e.position);if(n.lengthSquared()<=i*i-.02){const r=e.position.add(m.multiplyByFloat(n.normalize(),i)),o=this.transform.absolutePosition;t=o.add(m.multiplyByFloat(r.subtractInPlace(o).normalize(),this.boneLength))}})),t}}class M{constructor(e,t,i,n,r,o,a,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=r,this.center=o,this.hitRadius=a,this.bones=s,this.colliderGroups=l,this.verlets=[],this.initialLocalRotations=[],this.activeBones=[],this.drawGizmo=!1,this.boneGizmoList=[],this.colliderGizmoList=[],this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{e.rotationQuaternion=e.rotationQuaternion||e.rotation.toQuaternion(),this.initialLocalRotations.push(e.rotationQuaternion.clone())}))}setup(e=!1){e||this.activeBones.forEach(((e,t)=>{e.rotationQuaternion=this.initialLocalRotations[t].clone()})),this.verlets=[],this.activeBones.forEach(((e,t)=>{this.initialLocalRotations[t]=e.rotationQuaternion,this.setupRecursive(this.center,e)}))}async update(e,t){if(0===this.verlets.length){if(0===this.activeBones.length)return;this.setup()}this.updateOptions(t);const i=[];this.colliderGroups.forEach((e=>{if(!e)return;const t=e.transform.getAbsolutePosition();Number.isNaN(t.x)||e.colliders.forEach((n=>{const r=t.add(n.offset);if(i.push(new c(r,n.radius)),this.drawGizmo){if(this.colliderGizmoList.length<i.length){const t=f.MeshBuilder.CreateSphere(`${e.transform.name}_colliderGizmo`,{segments:8,diameter:1,updatable:!0},e.transform.getScene()),i=new u.StandardMaterial(e.transform.name+"_colliderGizmomat",e.transform.getScene());i.emissiveColor=a.Color3.Yellow(),i.wireframe=!0,t.material=i,this.colliderGizmoList.push(t)}this.colliderGizmoList[i.length-1].position=r,this.colliderGizmoList[i.length-1].scaling=new a.Vector3(2*n.radius,2*n.radius,2*n.radius)}}))}));const n=this.stiffness*e,r=m.multiplyByFloat(this.gravityDir,this.gravityPower*e),o=this.verlets.map(((e,t)=>new Promise((o=>{e.update(this.center,n,this.dragForce,r,i),this.drawGizmo&&this.boneGizmoList[t]&&(this.boneGizmoList[t].position=e.transform.absolutePosition,this.boneGizmoList[t].rotationQuaternion=e.transform.rotationQuaternion),o()}))));return Promise.all(o).then((()=>{}))}setupRecursive(e,t){if(0===t.getChildTransformNodes().length){const i=t.parent,n=t.getAbsolutePosition().subtract(i.getAbsolutePosition()).normalize(),r=t.position.add(m.multiplyByFloat(n,.07));this.verlets.push(new g(e,this.hitRadius,t,r))}else{const i=t.getChildTransformNodes().shift(),n=i.position,r=i.scaling;this.verlets.push(new g(e,this.hitRadius,t,n.multiply(r)))}if(this.drawGizmo){const e=f.MeshBuilder.CreateSphere(t.name+"_boneGizmo",{segments:8,diameter:2*this.hitRadius,updatable:!0},t.getScene()),i=new u.StandardMaterial(t.name+"_boneGizmomat",t.getScene());i.emissiveColor=a.Color3.Red(),i.wireframe=!0,e.material=i,this.boneGizmoList.push(e)}t.getChildTransformNodes().forEach((t=>{this.setupRecursive(e,t)}))}updateOptions(e){this.stiffness=e?.stiffness||this.stiffness,this.gravityPower=e?.gravityPower||this.gravityPower,this.gravityDir=e?.gravityDir||this.gravityDir,this.dragForce=e?.dragForce||this.dragForce,this.hitRadius=e?.hitRadius||this.hitRadius}}class _{constructor(e,t,i){this.ext=e;const n=this.constructColliderGroups(t);this.springs=this.constructSprings(t,n,i)}dispose(){this.springs=[]}setup(e=!1){this.springs.forEach((t=>{t.setup(e)}))}async update(e,t){e=Math.max(0,Math.min(16.666,e))/1e3;const i=this.springs.map((i=>i.update(e,t)));return Promise.all(i).then((()=>{}))}constructColliderGroups(e){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((i=>{const n=e(i.node),r=new h(n);i.colliders.forEach((e=>{r.addCollider(new a.Vector3(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(r)})),t}constructSprings(e,t,i){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const n=[];return this.ext.boneGroups.forEach((r=>{const o=(r.bones||[]).map((t=>e(t))),s=(r.colliderGroups||[]).map((e=>t[e]));n.push(new M(r.comment,i?.stiffness?i.stiffness:r.stiffiness,i?.gravityPower?i.gravityPower:r.gravityPower,i?.gravityDir?i.gravityDir:new a.Vector3(-r.gravityDir.x,-r.gravityDir.y,-r.gravityDir.z).normalize(),i?.dragForce?i.dragForce:r.dragForce,e(r.center),i?.hitRadius?i.hitRadius:r.hitRadius,o,s))})),n}}class v extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class A{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(e){const t=this.nodeMap[e];if(!t)throw new v(e);return t}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}class T{constructor(e,t,i){this.label=e,this.manager=i,this._value=t}get value(){return this._value}set value(e){this._value=Math.max(0,Math.min(1,e)),this.manager.morphing(this.label,e)}}class S{constructor(e,t,i,n,r){this.ext=e,this.scene=t,this.meshesFrom=i,this.transformNodesFrom=n,this.uri=r,this.morphTargetMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this._cameras=[],this.MorphTargetPropertyMap={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new _(this.ext.secondaryAnimation,this.findTransformNode.bind(this)),this.springBoneController.setup(),this.constructMorphTargetMap(),this.constructTransformNodeMap(),this._humanoidBone=new A(this.transformNodeMap),this.removeDuplicateSkeletons(),this._rootSkeleton=this.getRootSkeletonNode(),this.rootMesh.name=S.ROOT_MESH_PREFIX+this.scene.getNodes().filter((e=>e.name.includes(S.ROOT_MESH_PREFIX))).length}get cameras(){return this._cameras}appendCamera(e){this._cameras.push(e)}resetCameras(){this._cameras=[]}removeDuplicateSkeletons(){let e=null;for(const t of Object.keys(this.meshCache).map(Number)){const i=this.meshCache[t];if(i.length&&i[0].skeleton)if(e){e.bones.length!=i[0].skeleton.bones.length&&console.warn("Skeletons have different numbers of bones!"),i[0].skeleton.dispose();for(const t of i)t.skeleton=e}else if(e=i[0].skeleton,this._rootMesh){"Root"!==e.bones[0].name&&console.warn('The first bone has a different name than "Root"')}}}getRootSkeletonNode(){const e=this._rootMesh.getChildren((e=>"Root"===e.name||"Armature"===e.name));if(e.length>0)return e[0];{const e=this.scene.getNodeByName("Root")?this.scene.getNodeByName("Root"):this.scene.getNodeByName("Armature");if(e&&!e.parent)return e;throw Error("Cannot find root skeleton node!")}}async update(e,t){await this.springBoneController.update(e,t)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.MorphTargetPropertyMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}morphingPreset(e,t){this.presetMorphTargetMap[e]&&this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=Math.max(0,Math.min(1,t))*(e.weight/100)}))}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;let t=e.getAbsolutePosition();const i=this.ext.firstPerson.firstPersonBoneOffset;return new a.Vector3(t.x+i.x,t.y+i.y,t.z+i.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}get rootSkeletonNode(){return this._rootSkeleton}findTransformNode(e){return this.transformNodeCache[e]||null}findMeshes(e){return this.meshCache[e]||null}constructMorphTargetMap(){this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const r=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:r,weight:t.weight}),this.MorphTargetPropertyMap[e.name]=new T(e.name,0,this),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:r,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}setShadowEnabled(e){for(const t of Object.keys(this.meshCache).map(Number)){const i=this.meshCache[t];for(const t of i)t.receiveShadows=e}}}S.ROOT_MESH_PREFIX="vrm_root_";const x=(e=>{var t={};return n.d(t,e),t})({Material:()=>e.Material});function I(e,t,i,n){var r,o=arguments.length,a=o<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(a=(o<3?r(a):o>3?r(t,i,a):r(t,i))||a);return o>3&&a&&Object.defineProperty(t,i,a),a}Object.create;Object.create;const E=(e=>{var t={};return n.d(t,e),t})({SerializationHelper:()=>e.SerializationHelper,expandToProperty:()=>e.expandToProperty,serialize:()=>e.serialize,serializeAsColor3:()=>e.serializeAsColor3,serializeAsTexture:()=>e.serializeAsTexture});const L=(e=>{var t={};return n.d(t,e),t})({VertexBuffer:()=>e.VertexBuffer});const C=(e=>{var t={};return n.d(t,e),t})({PrePassConfiguration:()=>e.PrePassConfiguration});const D=(e=>{var t={};return n.d(t,e),t})({PushMaterial:()=>e.PushMaterial});const N=(e=>{var t={};return n.d(t,e),t})({MaterialHelper:()=>e.MaterialHelper});const O=(e=>{var t={};return n.d(t,e),t})({Constants:()=>e.Constants});const R=(e=>{var t={};return n.d(t,e),t})({EffectFallbacks:()=>e.EffectFallbacks});const y=(e=>{var t={};return n.d(t,e),t})({Effect:()=>e.Effect});const P=(e=>{var t={};return n.d(t,e),t})({DetailMapConfiguration:()=>e.DetailMapConfiguration});const b=(e=>{var t={};return n.d(t,e),t})({InspectableType:()=>e.InspectableType});function w(){return[{label:"DiffuseColor",propertyName:"diffuseColor",type:b.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:b.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:b.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:b.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:b.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:b.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:b.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:b.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:b.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:b.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:b.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:b.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:b.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:b.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:b.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:b.InspectableType.Slider,min:-.5,max:.5,step:.01}]}const F=(e=>{var t={};return n.d(t,e),t})({MaterialDefines:()=>e.MaterialDefines});class U extends F.MaterialDefines{constructor(){super(),this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.SPECULAR=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.SPECULARTERM=!1,this.NORMAL=!1,this.TANGENT=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.MULTIVIEW=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const X=(e=>{var t={};return n.d(t,e),t})({SceneComponentConstants:()=>e.SceneComponentConstants});class V{constructor(e,t){this.scene=e,this.material=t,this._savedDepthWrite=!1,this.name=`MToonOutline_${t.name}_${V.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine()}register(){this.scene._beforeRenderingMeshStage.registerStep(X.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(X.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){}render(e,t,i,n=!1){const r=t.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const o=t.getMesh(),a=o._internalAbstractMeshDataInfo._actAsRegularMesh?o:null,s=t.getRenderingMesh(),l=a||s;this._engine.enableEffect(r),s._bind(t,r,this.material.fillMode),this._engine.setZOffset(-1),s._processRendering(l,t,r,this.material.fillMode,i,this.isHardwareInstancedRendering(t,i),((i,n,o)=>{o.bindForSubMesh(n,e,t),r.setMatrix("world",n),r.setFloat("isOutline",1)}),this.material),this._engine.setZOffset(0)}_beforeRenderingMesh(e,t,i){if(this._savedDepthWrite=this._engine.getDepthWrite(),!this.willRender(t))return;const n=t.getMaterial();n.needAlphaBlendingForMesh(e)&&(this._engine.cacheStencilState(),this._engine.setDepthWrite(!1),this._engine.setColorWrite(!1),this._engine.setStencilBuffer(!0),this._engine.setStencilOperationPass(O.Constants.REPLACE),this._engine.setStencilFunction(O.Constants.ALWAYS),this._engine.setStencilMask(V._StencilReference),this._engine.setStencilFunctionReference(V._StencilReference),this.render(t.getRenderingMesh(),t,i,!0),this._engine.setColorWrite(!0),this._engine.setStencilFunction(O.Constants.NOTEQUAL)),this._engine.setDepthWrite(!1),this.render(t.getRenderingMesh(),t,i),this._engine.setDepthWrite(this._savedDepthWrite),n.needAlphaBlendingForMesh(e)&&this._engine.restoreStencilState()}_afterRenderingMesh(e,t,i){this.willRender(t)&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(t.getRenderingMesh(),t,i),this._engine.setColorWrite(!0))}isHardwareInstancedRendering(e,t){if(!this._engine.getCaps().instancedArrays)return!1;let i=!1;return i=e.getRenderingMesh().hasThinInstances,null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]||i}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}V._StencilReference=4,V.rendererId=0;const B=(e=>{var t={};return n.d(t,e),t})({Animation:()=>e.Animation,BackgroundMaterial:()=>e.BackgroundMaterial,Color3:()=>e.Color3,CubeTexture:()=>e.CubeTexture,DefaultRenderingPipeline:()=>e.DefaultRenderingPipeline,DepthOfFieldEffectBlurLevel:()=>e.DepthOfFieldEffectBlurLevel,HardwareScalingOptimization:()=>e.HardwareScalingOptimization,LensFlaresOptimization:()=>e.LensFlaresOptimization,Material:()=>e.Material,MaterialFlags:()=>e.MaterialFlags,Mesh:()=>e.Mesh,ParticlesOptimization:()=>e.ParticlesOptimization,RenderTargetsOptimization:()=>e.RenderTargetsOptimization,SceneOptimizer:()=>e.SceneOptimizer,SceneOptimizerOptions:()=>e.SceneOptimizerOptions,ShadowGenerator:()=>e.ShadowGenerator,SkeletonViewer:()=>e.SkeletonViewer,Texture:()=>e.Texture,TextureOptimization:()=>e.TextureOptimization,_TypeStore:()=>e._TypeStore}),W=n(463),H=n(486),G=n(477),z=n(677),k=n(984),Y=n(649),Q=n(854),j=n(483);var K,Z,$,q;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(K||(K={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(Z||(Z={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}($||($={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(q||(q={}));const J={effect:null,subMesh:null};class ee extends D.PushMaterial{constructor(e,t){super(e,t),this._diffuseTexture=null,this._ambientTexture=null,this._emissiveTexture=null,this._specularTexture=null,this._bumpTexture=null,this._shadeTexture=null,this._receiveShadowTexture=null,this._shadingGradeTexture=null,this._rimTexture=null,this._matCapTexture=null,this._outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.ambientColor=new a.Color3(0,0,0),this.diffuseColor=new a.Color3(1,1,1),this.specularColor=new a.Color3(1,1,1),this.emissiveColor=new a.Color3(0,0,0),this.shadeColor=new a.Color3(.97,.81,.86),this.rimColor=new a.Color3(0,0,0),this.outlineColor=new a.Color3(0,0,0),this.specularPower=64,this._useAlphaFromDiffuseTexture=!0,this._useEmissiveAsIllumination=!1,this._linkEmissiveWithDiffuse=!1,this._useSpecularOverAlpha=!1,this._disableLighting=!1,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this.alphaCutOff=.4,this._useGlossinessFromSpecularMapAlpha=!1,this._maxSimultaneousLights=4,this._twoSidedLighting=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.detailMap=new P.DetailMapConfiguration(this._markAllSubMeshesAsTexturesDirty.bind(this)),this._worldViewProjectionMatrix=a.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._bumpScale=.1,this.parallaxScaleBias=this._bumpScale,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._debugMode=K.None,this.debugMode=K.None,this.outlineRenderer=new V(this.getScene(),this),this._outlineWidthMode=$.None,this.outlineWidthMode=$.None,this._outlineColorMode=Z.MixedLighting,this.outlineColorMode=Z.MixedLighting,this._cullMode=q.Back,this._outlineCullMode=q.Front,this.outlineCullMode=q.Front,this.storedCullMode=q.Back,this.prePassConfiguration=new C.PrePassConfiguration,y.Effect.ShadersStore.mtoonVertexShader&&y.Effect.ShadersStore.mtoonFragmentShader||(y.Effect.IncludesShadersStore.mtoonUboDeclaration=W,y.Effect.IncludesShadersStore.mtoonVertexDeclaration=H,y.Effect.IncludesShadersStore.mtoonFragmentDeclaration=G,y.Effect.IncludesShadersStore.mtoonLightPreFragment=k,y.Effect.IncludesShadersStore.mtoonLightFragment=Y,y.Effect.IncludesShadersStore.mtoonBumpFragment=z,y.Effect.ShadersStore.mtoonVertexShader=Q,y.Effect.ShadersStore.mtoonFragmentShader=j),this.inspectableCustomProperties=this.inspectableCustomProperties?this.inspectableCustomProperties.concat(w()):w()}appendedActiveTextures(){return[this._diffuseTexture,this._ambientTexture,this._emissiveTexture,this._specularTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture].filter((e=>null!==e))}get isPrePassCapable(){return!0}get canRenderToMRT(){return!1}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case q.Off:this.backFaceCulling=!1,this.sideOrientation=x.Material.ClockWiseSideOrientation,this.twoSidedLighting=!0;break;case q.Front:this.backFaceCulling=!0,this.sideOrientation=x.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!1;break;case q.Back:this.backFaceCulling=!0,this.sideOrientation=x.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this.markAsDirty(x.Material.TextureDirtyFlag)}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported,this._markAllSubMeshesAsMiscDirty()}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}needAlphaTesting(){return!!this._forceAlphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===x.Material.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==x.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){if(t.effect&&this.isFrozen&&t.effect._wasPreviouslyReady)return!0;t._materialDefines||(t.materialDefines=new U);const n=this.getScene(),r=t._materialDefines;if(this._isReadyForSubMesh(t))return!0;const o=n.getEngine();if(r._needNormals=N.MaterialHelper.PrepareDefinesForLights(n,e,r,!0,this._maxSimultaneousLights,this._disableLighting)||this.outlineWidthMode!==$.None,N.MaterialHelper.PrepareDefinesForMultiview(n,r),N.MaterialHelper.PrepareDefinesForPrePass(n,r,this.canRenderToMRT),r._areTexturesDirty){this.applyDefines(r),r._needUVs=!1;for(let e=1;e<=O.Constants.MAX_SUPPORTED_UV_SETS;++e)r["MAINUV"+e]=!1;if(n.texturesEnabled){if(this._diffuseTexture&&ee.DiffuseTextureEnabled){if(!this._diffuseTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture,r,"DIFFUSE")}else r.DIFFUSE=!1;if(this._ambientTexture&&ee.AmbientTextureEnabled){if(!this._ambientTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture,r,"AMBIENT")}else r.AMBIENT=!1;if(this._emissiveTexture&&ee.EmissiveTextureEnabled){if(!this._emissiveTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture,r,"EMISSIVE")}else r.EMISSIVE=!1;if(this._specularTexture&&ee.SpecularTextureEnabled){if(!this._specularTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture,r,"SPECULAR"),r.GLOSSINESS=this._useGlossinessFromSpecularMapAlpha}else r.SPECULAR=!1;if(n.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,r,"BUMP"),r.PARALLAX=this._useParallax,r.PARALLAXOCCLUSION=this._useParallaxOcclusion,r.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap}else r.BUMP=!1;if(this._shadeTexture){if(!this._shadeTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._shadeTexture,r,"SHADE")}else r.SHADE=!1;if(this._receiveShadowTexture){if(!this._receiveShadowTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._receiveShadowTexture,r,"RECEIVE_SHADOW")}else r.RECEIVE_SHADOW=!1;if(this._shadingGradeTexture){if(!this._shadingGradeTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._shadingGradeTexture,r,"SHADING_GRADE")}else r.SHADING_GRADE=!1;if(this._rimTexture){if(!this._rimTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._rimTexture,r,"RIM")}else r.RIM=!1;if(this._matCapTexture){if(!this._matCapTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._matCapTexture,r,"MATCAP")}else r.MATCAP=!1;if(this._outlineWidthTexture){if(!this._outlineWidthTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._outlineWidthTexture,r,"OUTLINE_WIDTH")}else r.OUTLINE_WIDTH=!1;if(this._uvAnimationMaskTexture){if(!this._uvAnimationMaskTexture.isReadyOrNotBlocking())return!1;N.MaterialHelper.PrepareDefinesForMergedUV(this._uvAnimationMaskTexture,r,"UV_ANIMATION_MASK")}else r.UV_ANIMATION_MASK=!1;r.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else r.DIFFUSE=!1,r.AMBIENT=!1,r.EMISSIVE=!1,r.BUMP=!1,r.SHADE=!1,r.RECEIVE_SHADOW=!1,r.SHADING_GRADE=!1,r.RIM=!1,r.MATCAP=!1,r.OUTLINE_WIDTH=!1,r.UV_ANIMATION_MASK=!1;r.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),r.EMISSIVEASILLUMINATION=this._useEmissiveAsIllumination,r.LINKEMISSIVEWITHDIFFUSE=this._linkEmissiveWithDiffuse,r.SPECULAROVERALPHA=this._useSpecularOverAlpha,r.PREMULTIPLYALPHA=this.alphaMode===O.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===O.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,r.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,r.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(!this.detailMap.isReadyForSubMesh(r,n))return!1;if(N.MaterialHelper.PrepareDefinesForMisc(e,n,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(e)||this._forceAlphaTest,r),N.MaterialHelper.PrepareDefinesForAttributes(e,r,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha),N.MaterialHelper.PrepareDefinesForFrameBoundValues(n,o,r,i,null,t.getRenderingMesh().hasThinInstances),this.detailMap.prepareDefines(r,n),r.isDirty){const i=r._areLightsDisposed;r.markAsProcessed();const a=new R.EffectFallbacks;r.SPECULAR&&a.addFallback(0,"SPECULAR"),r.BUMP&&a.addFallback(0,"BUMP"),r.PARALLAX&&a.addFallback(1,"PARALLAX"),r.PARALLAXOCCLUSION&&a.addFallback(0,"PARALLAXOCCLUSION"),r.SPECULAROVERALPHA&&a.addFallback(0,"SPECULAROVERALPHA"),r.FOG&&a.addFallback(1,"FOG"),r.POINTSIZE&&a.addFallback(0,"POINTSIZE"),r.LOGARITHMICDEPTH&&a.addFallback(0,"LOGARITHMICDEPTH"),N.MaterialHelper.HandleFallbacksForShadows(r,a,this._maxSimultaneousLights),r.SPECULARTERM&&a.addFallback(0,"SPECULARTERM"),r.MULTIVIEW&&a.addFallback(0,"MULTIVIEW");const s=[L.VertexBuffer.PositionKind];r.NORMAL&&s.push(L.VertexBuffer.NormalKind),r.TANGENT&&s.push(L.VertexBuffer.TangentKind);for(let e=1;e<=O.Constants.MAX_SUPPORTED_UV_SETS;++e)r["UV"+e]&&s.push(`uv${1===e?"":e}`);r.VERTEXCOLOR&&s.push(L.VertexBuffer.ColorKind),N.MaterialHelper.PrepareAttributesForBones(s,e,r,a),N.MaterialHelper.PrepareAttributesForInstances(s,r),N.MaterialHelper.PrepareAttributesForMorphTargets(s,e,r);let l="mtoon";const d=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","visibility","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","diffuseMatrix","ambientMatrix","emissiveMatrix","specularMatrix","bumpMatrix","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","morphTargetTextureInfo","morphTargetTextureIndices"],h=["diffuseSampler","ambientSampler","emissiveSampler","specularSampler","bumpSampler","boneSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler","morphTargets"],u=["Material","Scene"];P.DetailMapConfiguration.AddUniforms(d),P.DetailMapConfiguration.AddSamplers(h),C.PrePassConfiguration.AddUniforms(d),C.PrePassConfiguration.AddSamplers(h),N.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:d,uniformBuffersNames:u,samplers:h,defines:r,maxSimultaneousLights:this._maxSimultaneousLights});const f={};this.customShaderNameResolve&&(l=this.customShaderNameResolve(l,d,u,h,r,s,f));const c=r.toString(),m=t.effect;let p=n.getEngine().createEffect(l,{attributes:s,uniformsNames:d,uniformBuffersNames:u,samplers:h,defines:c,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:r.NUM_MORPH_INFLUENCERS},processFinalCode:f.processFinalCode,multiTarget:r.PREPASS},o);if(p)if(this._onEffectCreatedObservable&&(J.effect=p,J.subMesh=t,this._onEffectCreatedObservable.notifyObservers(J)),this.allowShaderHotSwapping&&m&&!p.isReady()){if(p=m,r.markAsUnprocessed(),i)return r._areLightsDisposed=!0,!1}else n.resetCachedMaterial(),t.setEffect(p,r,this._materialContext),this.buildUniformLayout()}return!(!t.effect||!t.effect.isReady())&&(r._renderId=n.getRenderId(),t.effect._wasPreviouslyReady=!0,!0)}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vSpecularColor",4),e.addUniform("vSpecularInfos",2),e.addUniform("specularMatrix",16),e.addUniform("vAmbientColor",3),e.addUniform("vAmbientInfos",2),e.addUniform("ambientMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("alphaCutOff",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),P.DetailMapConfiguration.PrepareUniformBuffer(e),e.create()}unbind(){super.unbind()}bindForSubMesh(e,t,n){const r=this.getScene(),o=n._materialDefines;if(!o)return;const s=n.effect;if(!s)return;this._activeEffect=s,t.getMeshUniformBuffer().bindToEffect(s,"Mesh"),t.transferToEffect(e),this.prePassConfiguration.bindForSubMesh(this._activeEffect,r,t,e,this.isFrozen),o.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const l=this._mustRebind(r,s,t.visibility);N.MaterialHelper.BindBonesParameters(t,s);const d=this._uniformBuffer;l&&(d.bindToEffect(s,"Material"),this.bindViewProjection(s),d.useUbo&&this.isFrozen&&d.isSync||r.texturesEnabled&&(this._diffuseTexture&&ee.DiffuseTextureEnabled&&(d.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),N.MaterialHelper.BindTextureMatrix(this._diffuseTexture,d,"diffuse")),this._ambientTexture&&ee.AmbientTextureEnabled&&(d.updateFloat2("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level),N.MaterialHelper.BindTextureMatrix(this._ambientTexture,d,"ambient")),this._hasAlphaChannel()&&d.updateFloat("alphaCutOff",this.alphaCutOff),this._emissiveTexture&&ee.EmissiveTextureEnabled&&(d.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),N.MaterialHelper.BindTextureMatrix(this._emissiveTexture,d,"emissive")),this._specularTexture&&ee.SpecularTextureEnabled&&(d.updateFloat2("vSpecularInfos",this._specularTexture.coordinatesIndex,this._specularTexture.level),N.MaterialHelper.BindTextureMatrix(this._specularTexture,d,"specular")),this._bumpTexture&&r.getEngine().getCaps().standardDerivatives&&ee.BumpTextureEnabled&&(d.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this.parallaxScaleBias),N.MaterialHelper.BindTextureMatrix(this._bumpTexture,d,"bump"),r._mirroredCameraPosition?d.updateFloat2("vTangentSpaceParams",-1,-1):d.updateFloat2("vTangentSpaceParams",1,1)),this._shadeTexture&&(d.updateFloat2("vShadeInfos",this._shadeTexture.coordinatesIndex,this._shadeTexture.level),N.MaterialHelper.BindTextureMatrix(this._shadeTexture,d,"shade")),this._receiveShadowTexture&&(d.updateFloat2("vReceiveShadowInfos",this._receiveShadowTexture.coordinatesIndex,this._receiveShadowTexture.level),N.MaterialHelper.BindTextureMatrix(this._receiveShadowTexture,d,"receiveShadow")),this._shadingGradeTexture&&(d.updateFloat2("vShadingGradeInfos",this._shadingGradeTexture.coordinatesIndex,this._shadingGradeTexture.level),N.MaterialHelper.BindTextureMatrix(this._shadingGradeTexture,d,"shadingGrade")),this._rimTexture&&(d.updateFloat2("vRimInfos",this._rimTexture.coordinatesIndex,this._rimTexture.level),N.MaterialHelper.BindTextureMatrix(this._rimTexture,d,"rim")),this._matCapTexture&&(d.updateFloat2("vMatCapInfos",this._matCapTexture.coordinatesIndex,this._matCapTexture.level),N.MaterialHelper.BindTextureMatrix(this._matCapTexture,d,"matCap")),this._outlineWidthTexture&&(d.updateFloat2("vOutlineWidthInfos",this._outlineWidthTexture.coordinatesIndex,this._outlineWidthTexture.level),N.MaterialHelper.BindTextureMatrix(this._outlineWidthTexture,d,"outlineWidth")),this._uvAnimationMaskTexture&&(d.updateFloat2("vUvAnimationMaskInfos",this._uvAnimationMaskTexture.coordinatesIndex,this._uvAnimationMaskTexture.level),N.MaterialHelper.BindTextureMatrix(this._uvAnimationMaskTexture,d,"uvAnimationMask"))),this.pointsCloud&&d.updateFloat("pointSize",this.pointSize),o.SPECULARTERM&&d.updateColor4("vSpecularColor",this.specularColor,this.specularPower),d.updateColor3("vEmissiveColor",this.emissiveColor),d.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),r.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),d.updateColor3("vAmbientColor",this._globalAmbientColor),d.updateFloat("receiveShadowRate",this._receiveShadowRate),d.updateFloat("shadingGradeRate",this._shadingGradeRate),d.updateFloat("shadeShift",this._shadeShift),d.updateFloat("shadeToony",this._shadeToony),d.updateFloat("lightColorAttenuation",this._lightColorAttenuation),d.updateFloat("indirectLightIntensity",this._indirectLightIntensity),d.updateFloat("rimLightingMix",this._rimLightingMix),d.updateFloat("rimFresnelPower",this._rimFresnelPower),d.updateFloat("rimLift",this._rimLift),d.updateFloat("outlineWidth",this._outlineWidth),d.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),d.updateFloat("outlineLightingMix",this._outlineLightingMix),d.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),d.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),d.updateFloat("uvAnimationRotation",this._uvAnimationRotation),r.texturesEnabled&&(this._diffuseTexture&&ee.DiffuseTextureEnabled&&s.setTexture("diffuseSampler",this._diffuseTexture),this._ambientTexture&&ee.AmbientTextureEnabled&&s.setTexture("ambientSampler",this._ambientTexture),this._emissiveTexture&&ee.EmissiveTextureEnabled&&s.setTexture("emissiveSampler",this._emissiveTexture),this._specularTexture&&ee.SpecularTextureEnabled&&s.setTexture("specularSampler",this._specularTexture),this._bumpTexture&&r.getEngine().getCaps().standardDerivatives&&ee.BumpTextureEnabled&&s.setTexture("bumpSampler",this._bumpTexture),this._shadeTexture&&s.setTexture("shadeSampler",this._shadeTexture),this._receiveShadowTexture&&s.setTexture("receiveShadowSampler",this._receiveShadowTexture),this._shadingGradeTexture&&s.setTexture("shadingGradeSampler",this._shadingGradeTexture),this._rimTexture&&s.setTexture("rimSampler",this._rimTexture),this._matCapTexture&&s.setTexture("matCapSampler",this._matCapTexture),this._outlineWidthTexture&&s.setTexture("outlineWidthSampler",this._outlineWidthTexture),this._uvAnimationMaskTexture&&s.setTexture("uvAnimationMaskSampler",this._uvAnimationMaskTexture)),this.detailMap.bindForSubMesh(d,r,this.isFrozen),N.MaterialHelper.BindClipPlane(s,r),this.bindEyePosition(s),s.setVector3("vEyeUp",r.activeCamera.upVector),d.updateColor3("vShadeColor",this.shadeColor),d.updateColor3("vRimColor",this.rimColor),d.updateColor4("vOutlineColor",this.outlineColor,1)),!l&&this.isFrozen||(r.lightsEnabled&&!this._disableLighting&&N.MaterialHelper.BindLights(r,t,s,o,this._maxSimultaneousLights),(r.fogEnabled&&t.applyFog&&r.fogMode!==i.Scene.FOGMODE_NONE||t.receiveShadows)&&this.bindView(s),N.MaterialHelper.BindFogParameters(r,t,s),o.NUM_MORPH_INFLUENCERS&&N.MaterialHelper.BindMorphTargetParameters(t,s),this.useLogarithmicDepth&&N.MaterialHelper.BindLogDepth(o,s,r)),s.setFloat("aspect",r.getEngine().getAspectRatio(r.activeCamera)),s.setFloat("isOutline",0);const h=window.performance.now()/1e3;s.setVector4("time",new a.Vector4(h/20,h,2*h,3*h)),this._afterBind(t,this._activeEffect),d.update()}getAnimatables(){const e=[];for(const t of this.appendedActiveTextures())t.animations&&t.animations.length>0&&e.push(t);return this.detailMap.getAnimatables(e),e}getActiveTextures(){const e=super.getActiveTextures().concat(this.appendedActiveTextures());return this.detailMap.getActiveTextures(e),e}hasTexture(e){if(super.hasTexture(e))return!0;const t=this.appendedActiveTextures();return t.length>0?t.some((t=>t===e)):this.detailMap.hasTexture(e)}dispose(e,t){t&&this.appendedActiveTextures().forEach((e=>e.dispose())),this.detailMap.dispose(t),super.dispose(e,t)}applyDefines(e){switch(this._debugMode){case K.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case K.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case K.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this._outlineWidthMode){case $.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case $.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case $.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this._outlineColorMode){case Z.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case Z.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}clone(e){const t=E.SerializationHelper.Clone((()=>new ee(e,this.getScene())),this);return t.name=e,t.id=e,this.stencil.copyTo(t.stencil),t}serialize(){const e=E.SerializationHelper.Serialize(this);return e.stencil=this.stencil.serialize(),e}static Parse(e,t,i){const n=E.SerializationHelper.Parse((()=>new ee(e.name,t)),e,t,i);return e.stencil&&n.stencil.parse(e.stencil,t,i),n}static get DiffuseTextureEnabled(){return B.MaterialFlags.DiffuseTextureEnabled}static set DiffuseTextureEnabled(e){B.MaterialFlags.DiffuseTextureEnabled=e}static get AmbientTextureEnabled(){return B.MaterialFlags.AmbientTextureEnabled}static set AmbientTextureEnabled(e){B.MaterialFlags.AmbientTextureEnabled=e}static get EmissiveTextureEnabled(){return B.MaterialFlags.EmissiveTextureEnabled}static set EmissiveTextureEnabled(e){B.MaterialFlags.EmissiveTextureEnabled=e}static get SpecularTextureEnabled(){return B.MaterialFlags.SpecularTextureEnabled}static set SpecularTextureEnabled(e){B.MaterialFlags.SpecularTextureEnabled=e}static get BumpTextureEnabled(){return B.MaterialFlags.BumpTextureEnabled}static set BumpTextureEnabled(e){B.MaterialFlags.BumpTextureEnabled=e}}var te;I([(0,E.serializeAsTexture)("diffuseTexture")],ee.prototype,"_diffuseTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"diffuseTexture",void 0),I([(0,E.serializeAsTexture)("ambientTexture")],ee.prototype,"_ambientTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"ambientTexture",void 0),I([(0,E.serializeAsTexture)("emissiveTexture")],ee.prototype,"_emissiveTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"emissiveTexture",void 0),I([(0,E.serializeAsTexture)("specularTexture")],ee.prototype,"_specularTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"specularTexture",void 0),I([(0,E.serializeAsTexture)("bumpTexture")],ee.prototype,"_bumpTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"bumpTexture",void 0),I([(0,E.serializeAsTexture)("shadeTexture")],ee.prototype,"_shadeTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"shadeTexture",void 0),I([(0,E.serializeAsTexture)("receiveShadowTexture")],ee.prototype,"_receiveShadowTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"receiveShadowTexture",void 0),I([(0,E.serializeAsTexture)("shadingGradeTexture")],ee.prototype,"_shadingGradeTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"shadingGradeTexture",void 0),I([(0,E.serializeAsTexture)("rimTexture")],ee.prototype,"_rimTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"rimTexture",void 0),I([(0,E.serializeAsTexture)("matCapTexture")],ee.prototype,"_matCapTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"matCapTexture",void 0),I([(0,E.serializeAsTexture)("outlineWidthTexture")],ee.prototype,"_outlineWidthTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"outlineWidthTexture",void 0),I([(0,E.serializeAsTexture)("uvAnimationMaskTexture")],ee.prototype,"_uvAnimationMaskTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"uvAnimationMaskTexture",void 0),I([(0,E.serializeAsColor3)("ambient")],ee.prototype,"ambientColor",void 0),I([(0,E.serializeAsColor3)("diffuse")],ee.prototype,"diffuseColor",void 0),I([(0,E.serializeAsColor3)("specular")],ee.prototype,"specularColor",void 0),I([(0,E.serializeAsColor3)("emissive")],ee.prototype,"emissiveColor",void 0),I([(0,E.serializeAsColor3)("shade")],ee.prototype,"shadeColor",void 0),I([(0,E.serializeAsColor3)("rim")],ee.prototype,"rimColor",void 0),I([(0,E.serializeAsColor3)("outline")],ee.prototype,"outlineColor",void 0),I([(0,E.serialize)()],ee.prototype,"specularPower",void 0),I([(0,E.serialize)("useAlphaFromDiffuseTexture")],ee.prototype,"_useAlphaFromDiffuseTexture",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"useAlphaFromDiffuseTexture",void 0),I([(0,E.serialize)("useEmissiveAsIllumination")],ee.prototype,"_useEmissiveAsIllumination",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useEmissiveAsIllumination",void 0),I([(0,E.serialize)("linkEmissiveWithDiffuse")],ee.prototype,"_linkEmissiveWithDiffuse",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"linkEmissiveWithDiffuse",void 0),I([(0,E.serialize)("useSpecularOverAlpha")],ee.prototype,"_useSpecularOverAlpha",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useSpecularOverAlpha",void 0),I([(0,E.serialize)("disableLighting")],ee.prototype,"_disableLighting",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"disableLighting",void 0),I([(0,E.serialize)("useObjectSpaceNormalMap")],ee.prototype,"_useObjectSpaceNormalMap",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useObjectSpaceNormalMap",void 0),I([(0,E.serialize)("useParallax")],ee.prototype,"_useParallax",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useParallax",void 0),I([(0,E.serialize)("useParallaxOcclusion")],ee.prototype,"_useParallaxOcclusion",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useParallaxOcclusion",void 0),I([(0,E.serialize)()],ee.prototype,"alphaCutOff",void 0),I([(0,E.serialize)("useGlossinessFromSpecularMapAlpha")],ee.prototype,"_useGlossinessFromSpecularMapAlpha",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"useGlossinessFromSpecularMapAlpha",void 0),I([(0,E.serialize)("maxSimultaneousLights")],ee.prototype,"_maxSimultaneousLights",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"maxSimultaneousLights",void 0),I([(0,E.serialize)("twoSidedLighting")],ee.prototype,"_twoSidedLighting",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],ee.prototype,"twoSidedLighting",void 0),I([(0,E.serialize)("bumpScale")],ee.prototype,"_bumpScale",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],ee.prototype,"bumpScale",void 0),I([(0,E.serialize)()],ee.prototype,"parallaxScaleBias",void 0),I([(0,E.serialize)("receiveShadowRate")],ee.prototype,"_receiveShadowRate",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"receiveShadowRate",void 0),I([(0,E.serialize)("shadingGradeRate")],ee.prototype,"_shadingGradeRate",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadingGradeRate",void 0),I([(0,E.serialize)("shadeShift")],ee.prototype,"_shadeShift",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadeShift",void 0),I([(0,E.serialize)("shadeToony")],ee.prototype,"_shadeToony",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"shadeToony",void 0),I([(0,E.serialize)("lightColorAttenuation")],ee.prototype,"_lightColorAttenuation",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"lightColorAttenuation",void 0),I([(0,E.serialize)("indirectLightIntensity")],ee.prototype,"_indirectLightIntensity",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"indirectLightIntensity",void 0),I([(0,E.serialize)("rimLightingMix")],ee.prototype,"_rimLightingMix",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimLightingMix",void 0),I([(0,E.serialize)("rimFresnelPower")],ee.prototype,"_rimFresnelPower",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimFresnelPower",void 0),I([(0,E.serialize)("rimLift")],ee.prototype,"_rimLift",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsLightsDirty")],ee.prototype,"rimLift",void 0),I([(0,E.serialize)("outlineWidth")],ee.prototype,"_outlineWidth",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineWidth",void 0),I([(0,E.serialize)("outlineScaledMaxDistance")],ee.prototype,"_outlineScaledMaxDistance",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineScaledMaxDistance",void 0),I([(0,E.serialize)("outlineLightingMix")],ee.prototype,"_outlineLightingMix",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsAttributesDirty")],ee.prototype,"outlineLightingMix",void 0),I([(0,E.serialize)("uvAnimationScrollX")],ee.prototype,"_uvAnimationScrollX",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationScrollX",void 0),I([(0,E.serialize)("uvAnimationScrollY")],ee.prototype,"_uvAnimationScrollY",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationScrollY",void 0),I([(0,E.serialize)("uvAnimationRotation")],ee.prototype,"_uvAnimationRotation",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"uvAnimationRotation",void 0),I([(0,E.serialize)("debugMode")],ee.prototype,"_debugMode",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"debugMode",void 0),I([(0,E.serialize)("outlineWidthMode")],ee.prototype,"_outlineWidthMode",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineWidthMode",void 0),I([(0,E.serialize)("outlineColorMode")],ee.prototype,"_outlineColorMode",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineColorMode",void 0),I([(0,E.serialize)("cullMode")],ee.prototype,"_cullMode",void 0),I([(0,E.serialize)("outlineCullMode")],ee.prototype,"_outlineCullMode",void 0),I([(0,E.expandToProperty)("_markAllSubMeshesAsMiscDirty")],ee.prototype,"outlineCullMode",void 0),I([(0,E.serialize)()],ee.prototype,"useLogarithmicDepth",null),B._TypeStore.RegisteredTypes["BABYLON.MToonMaterial"]=ee,function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(te||(te={}));const ie=(e=>{var t={};return n.d(t,e),t})({Engine:()=>e.Engine});class ne{constructor(e){this.loader=e}generate(e,t,i,n,r){const o=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!o)return null;i.alphaIndex=o.renderQueue;const a=this.createMaterialByShader(e,t,n,o);return a?(r(a),a instanceof ee?this.loadMToonTexturesAsync(e,a,o):Promise.resolve(a)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],r=i.vectorProperties._MainTex;if(!r)return Promise.resolve(t);const o=(t,i)=>{re(t,(o=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:o},(e=>{const t=e;t.uOffset=r[0],t.vOffset=r[1],t.uScale=r[2],t.vScale=r[3],i(e)})))}))};return o(i.textureProperties._MainTex,(e=>{t.diffuseTexture=e,t.transparencyMode&&(t.diffuseTexture.hasAlpha=!0)})),o(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),o(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),o(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),o(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),o(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),o(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),o(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),o(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),o(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===te.VRMMToon){const e=new ee(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===te.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){re(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),re(t.vectorProperties._Color,(t=>{e.diffuseColor=new a.Color3(t[0],t[1],t[2]),e.alpha=t[3]})),re(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new a.Color3(t[0],t[1],t[2])})),re(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),re(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),re(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),re(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),re(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),re(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),re(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),re(t.vectorProperties._RimColor,(t=>{e.rimColor=new a.Color3(t[0],t[1],t[2])})),re(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),re(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),re(t.floatProperties._RimLift,(t=>e.rimLift=t)),re(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new a.Color3(t[0],t[1],t[2])})),re(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),re(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),re(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new a.Color3(t[0],t[1],t[2])})),re(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),re(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),re(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),re(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),re(t.floatProperties._DebugMode,(t=>e.debugMode=t)),re(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.transparencyMode=x.Material.MATERIAL_OPAQUE;break;case 1:e.transparencyMode=x.Material.MATERIAL_ALPHATEST,e.alphaMode=ie.Engine.ALPHA_COMBINE;break;case 2:e.transparencyMode=x.Material.MATERIAL_ALPHABLEND,e.alphaMode=ie.Engine.ALPHA_COMBINE}})),re(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),re(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),re(t.floatProperties._CullMode,(t=>e.cullMode=t)),re(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),re(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function re(e,t){void 0!==e&&t(e)}class oe{constructor(e,t){this.loader=e,this.v3DCore=t,this.name=oe.NAME,this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.loaderObservers=[],this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.addLoaderObserver(this.v3DCore),this.onLoadedCallBack=()=>{t.addVRMManager(this.manager)},t.addOnLoadCompleteCallbacks(this.onLoadedCallBack)}dispose(){this.loader=null,this.loaderObservers=[],this.v3DCore.removeOnLoadCompleteCallback(this.onLoadedCallBack)}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions[oe.NAME])return;const e=this.loader.parent.uri;this.manager=new S(this.loader.gltf.extensions[oe.NAME],this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,e),this.loader.babylonScene.onDisposeObservable.add((()=>{this.manager.dispose()}));for(const e of this.loaderObservers)e.onLoadReady();console.log("extension onReady")}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,r){return new ne(this.loader).generate(e,t,i,n,r)}addLoaderObserver(e){this.loaderObservers.push(e)}}oe.NAME="VRM";const ae=(e=>{var t={};return n.d(t,e),t})({GLTFLoader:()=>e.GLTFLoader});const se=(e=>{var t={};return n.d(t,e),t})({HemisphericLight:()=>e.HemisphericLight});function le(e){return void 0!==e.setShadowProjectionMatrix}class de{constructor(e){this.scene=e,this._options=de.CustomOptimizerOptions(),this._optimizer=new B.SceneOptimizer(e,this._options),this._optimizer.targetFrameRate=fe.FRAMERATE,this._optimizer.trackerDuration=2e3,this._optimizer.start(),this.setupFocusEvents(this._optimizer)}get options(){return this._options}set options(e){this._options=e}get optimizer(){return this._optimizer}static CustomOptimizerOptions(){const e=new B.SceneOptimizerOptions;return e.addOptimization(new B.LensFlaresOptimization(0)),e.addOptimization(new B.ParticlesOptimization(1)),e.addOptimization(new B.TextureOptimization(2,512)),e.addOptimization(new B.RenderTargetsOptimization(3)),e.addOptimization(new B.HardwareScalingOptimization(4,2)),e}setupFocusEvents(e){window&&(console.log("setupFocusEvents"),window.addEventListener("focusin",(function(t){console.log("Optimizer start"),e.start()}),!0),window.addEventListener("focusout",(function(t){console.log("Optimizer stop"),e.stop(),e.reset()}),!0))}}const he=(e=>{var t={};return n.d(t,e),t})({SkyMaterial:()=>e.SkyMaterial});class ue{constructor(e,t,i,n){this.scene=e,this.textureName=t,this.boxSize=i,this.envTexture=n,this._skybox=B.Mesh.CreateBox("Skybox",i,this.scene,void 0,B.Mesh.BACKSIDE),this._skyboxBase=B.Mesh.CreateBox("SkyboxBase",i+1,this.scene,void 0,B.Mesh.BACKSIDE),this.createMaterial(t),this._skybox.material=this.skyboxMaterial,this._skyboxBase.material=this.skyboxBaseMaterial,this._skybox.renderingGroupId=0,this._skyboxBase.renderingGroupId=0,this._skybox.material.transparencyMode=B.Material.MATERIAL_ALPHATESTANDBLEND,this._skybox.material.alpha=.5,this.setupImageProcessing()}get skybox(){return this._skybox}createMaterial(e){this.skyboxBaseMaterial=new he.SkyMaterial("SkyboxBaseMaterial",this.scene),this.skyboxMaterial=new B.BackgroundMaterial("SkyboxMaterial",this.scene),this.skyboxMaterial.backFaceCulling=!1,this.skyboxMaterial.useRGBColor=!1,this.skyboxMaterial.primaryColor=new B.Color3(1,1,1),this.skyboxMaterial.enableNoise=!0,this.skyboxReflectionTexture=new B.CubeTexture(e,this.scene),this.skyboxReflectionTexture.coordinatesMode=B.Texture.SKYBOX_MODE,this.skyboxReflectionTexture.gammaSpace=!1,this.skyboxMaterial.reflectionTexture=this.skyboxReflectionTexture}setupImageProcessing(){this.scene.imageProcessingConfiguration.contrast=1.2,this.scene.imageProcessingConfiguration.exposure=.8,this.scene.imageProcessingConfiguration.toneMappingEnabled=!0,this.scene.environmentTexture=this.envTexture?this.envTexture:B.CubeTexture.CreateFromPrefilteredData(ue._environmentTextureCDNUrl,this.scene)}}ue._environmentTextureCDNUrl="https://assets.babylonjs.com/environments/environmentSpecular.env";class fe{constructor(e,t,n){this.engine=e,this.scene=t,this._vrmFileLoader=new l,this._shadowGenerators=new Map,this._onLoadCompleteCallbacks=[],this._managerRenderFunc=()=>{for(const e of this.loadedVRMManagers)e.update(this.engine.getDeltaTime())},this._cameraOnBeforeRenderFunc=[],this.skyBox=null,this.loadedVRMManagers=[],this.registerVrmPlugin(),this.registerVrmExtension(),this.scene?this.engine=this.scene.getEngine():this.scene=new i.Scene(this.engine),this.setupSecodaryAnimation(),this.enableResize(),n?(this._mainCamera=n,this.scene.switchActiveCamera(n)):this.addCamera(),this._renderingPipeline=new B.DefaultRenderingPipeline("defaultPipeline",!0,this.scene,[this._mainCamera]),this.setupRenderingPipeline()}get renderingPipeline(){return this._renderingPipeline}addOnLoadCompleteCallbacks(e){this._onLoadCompleteCallbacks.push(e)}removeOnLoadCompleteCallback(e){const t=this._onLoadCompleteCallbacks.indexOf(e);-1!==t&&this._onLoadCompleteCallbacks.splice(t,1)}resetOnLoadCompleteCallbacks(){this._onLoadCompleteCallbacks=[]}updateManagerRenderFunction(e){this._managerRenderFunc=e}get mainCamera(){return this._mainCamera}set mainCamera(e){this._mainCamera=e}addVRMManager(e){e&&this.loadedVRMManagers.push(e)}getVRMManagerByIndex(e){return e>=0&&e<this.loadedVRMManagers.length?this.loadedVRMManagers[e]:null}getVRMManagerByURI(e){for(const t of this.loadedVRMManagers)if(t.uri===e)return t;return null}transparentBackground(){this.scene.clearColor.a=0}solidBackground(){this.scene.clearColor.a=1}setBackgroundColor(e){this.scene.clearColor=a.Color4.FromColor3(e,this.scene.clearColor.a).toLinearSpace()}addAmbientLight(e){const t=new se.HemisphericLight("V3DHemiLight",new a.Vector3(0,1,1),this.scene);e&&(t.diffuse=e),t.setEnabled(!0)}addCamera(e=3){const i=new t.ArcRotateCamera("V3DMainCamera",0,0,e,new a.Vector3(0,0,0),this.scene,!0);i.lowerRadiusLimit=.1,i.upperRadiusLimit=20,i.wheelDeltaPercentage=.05,i.minZ=0,i.setPosition(new a.Vector3(0,1.5,-5)),i.attachControl(this.engine.getRenderingCanvas()),this._mainCamera=i,this.scene.switchActiveCamera(this._mainCamera,!0)}attachCameraTo(e,i=3){const n=new t.ArcRotateCamera("V3DArcCamera"+e.cameras.length,0,0,i,e.rootMesh.position,this.scene,!0);n.lowerRadiusLimit=.1,n.upperRadiusLimit=20,n.wheelDeltaPercentage=.05,n.minZ=0,n.setPosition(new a.Vector3(0,1.5,-5)),n.setTarget(e.rootMesh.getAbsolutePosition()),n.attachControl(this.engine.getRenderingCanvas()),e.appendCamera(n),this._cameraOnBeforeRenderFunc.push((()=>{n.setTarget(e.rootMesh.getAbsolutePosition())}))}createSkyBox(e,t){this.skyBox||(this.skyBox=new ue(this.scene,t||"texture/skybox",e))}enableShabows(e){if(e)if(this._shadowGenerators.has(e))console.warn("Light "+e.name+" already has a shadow generator!");else{const t=new B.ShadowGenerator(1024,e);this.setupShadowGenerator(t),this._shadowGenerators.set(e,t)}else for(const e of this.scene.lights)if(le(e)){const t=new B.ShadowGenerator(1024,e);this.setupShadowGenerator(t),this._shadowGenerators.set(e,t)}}getShadownGenerator(e){return this._shadowGenerators.get(e)}startQuickAnimation(e,t,i,n,r,o,a,s,l){const d=this.createAnimation(e,t,i,[{frame:0,value:r},{frame:n,value:o}],a,s,l);return this.scene.beginDirectAnimation(d[0],[d[1]],0,n,!1)}createAnimation(e,t,i,n,r,o,s){if(n.length<1)throw Error("Key Frames empty");const l=function(e){let t;return!isNaN(parseFloat(e))&&isFinite(e)?t=B.Animation.ANIMATIONTYPE_FLOAT:e instanceof a.Quaternion?t=B.Animation.ANIMATIONTYPE_QUATERNION:e instanceof a.Vector3?t=B.Animation.ANIMATIONTYPE_VECTOR3:e instanceof a.Vector2?t=B.Animation.ANIMATIONTYPE_VECTOR2:e instanceof a.Color3?t=B.Animation.ANIMATIONTYPE_COLOR3:e instanceof a.Color4?t=B.Animation.ANIMATIONTYPE_COLOR4:e instanceof a.Size&&(t=B.Animation.ANIMATIONTYPE_SIZE),null==t?null:t}(n[0].value);if(null===l)throw Error("Cannot determine data type from keyframes!");const d=new B.Animation(t,i,fe.FRAMERATE,l,r);return d.setKeys(n),o&&(s&&o.setEasingMode(s),d.setEasingFunction(o)),[e,d]}enableOptimizer(){this._sceneOptimizer=new de(this.scene)}AppendAsync(e,t){return o.SceneLoader.AppendAsync(e,t,this.scene)}LoadAsync(e,t){return o.SceneLoader.LoadAsync(e,t,this.engine)}onLoadReady(){for(const e of this._onLoadCompleteCallbacks)e()}setupSecodaryAnimation(){this.scene.onBeforeRenderObservable.add(((e,t)=>{this._managerRenderFunc(e,t)})),this.scene.onBeforeRenderObservable.add((()=>{for(const e of this._cameraOnBeforeRenderFunc)e()}))}enableResize(){this.engine.getRenderingCanvas().onresize=()=>{this.engine.resize()}}setupShadowGenerator(e){e.usePercentageCloserFiltering=!0,e.filteringQuality=B.ShadowGenerator.QUALITY_HIGH}registerVrmExtension(){ae.GLTFLoader.RegisterExtension(oe.NAME,(e=>new oe(e,this)))}registerVrmPlugin(){o.SceneLoader&&o.SceneLoader.RegisterPlugin(this._vrmFileLoader)}setupRenderingPipeline(){this._renderingPipeline.samples=4,this._renderingPipeline.depthOfFieldEnabled=!0,this._renderingPipeline.depthOfFieldBlurLevel=B.DepthOfFieldEffectBlurLevel.Medium,this._renderingPipeline.depthOfField.focusDistance=2e3,this._renderingPipeline.depthOfField.focalLength=10,this._renderingPipeline.depthOfField.fStop=1.4}}fe.FRAMERATE=60;class ce{constructor(e){this.core=e}addNodeToShadowCasterByName(e,t){e.addShadowCaster(this.core.scene.getNodeByName(t))}addNodeToShadowCasterContainsName(e,t){for(const i of this.core.scene.getNodes())i&&i.name.includes(t)&&e.addShadowCaster(i)}makeReceiveShadowByName(e){this.core.scene.getNodeByName(e).receiveShadows=!0}makeReceiveShadowContainsName(e){for(const t of this.core.scene.getNodes())if(t&&t.name.includes(e))try{t.receiveShadows=!0}catch(e){console.log(e)}}showSkeletonDebug(e,t){const i={pauseAnimations:!0,returnToRest:!1,computeBonesUsingShaders:!0,useAllBones:!0,displayMode:B.SkeletonViewer.DISPLAY_LINES};return new B.SkeletonViewer(e,t,this.core.scene,!0,t.renderingGroupId>0?t.renderingGroupId+1:1,i)}}})();var o=r.M,a=r.L;export{o as V3DCore,a as V3DHelper};